{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"solvency2-data","text":"<p>Python Package for reading the Solvency 2 Risk-Free Interest Rate Term Structures from the zip-files on the EIOPA website and deriving the term structures for alternative extrapolations.</p> <ul> <li>Free software: MIT/X license</li> <li>Documentation: https://wjwillemse.github.io/solvency2-data.</li> </ul> <p></p>"},{"location":"#features","title":"Features","text":"<p>Here is what the package does:</p> <ul> <li>Downloading and extracting the zip-files from the EIOPA website</li> <li>Store the financial data in a local database</li> <li>Reading the term structures from Excel-files into Pandas DataFrames</li> <li>Deriving term structures with other parameters for alternative     extrapolations</li> </ul>"},{"location":"#contributors","title":"Contributors","text":"<ul> <li>Willem Jan Willemse https://github.com/wjwillemse</li> <li>Peter Davidson https://github.com/pdavidsonFIA</li> </ul>"},{"location":"api_docs/","title":"API documentation","text":"<p>Main module.</p> <p>Downloads rfr and stores in sqlite database for future reference</p> <p>Returns links for EIOPA files</p> <p>This module contains all the handler functions for the sqlite database storing the data</p> <p>Calculates Smith-Wilson parameters and returns output based on the specified parameters.</p> <p>Note: Prices of all instruments are set to 1 by construction. Hence 1: if Instrument = Zero then for Zero i there is only one pay-off of (1+r(i))^u(i) at time u(i). Hence 2: if Instrument = Swap or Bond then for Swap/Bond i there are pay-offs of r(i)/nrofcoup at time 1/nrofcoup, 2/nrofcoup, ... u(i)-1/nrofcoup plus a final pay-off of 1+r(i)/nrofcoup at time u(i).</p> <p>Parameters:</p> Name Type Description Default <code>instrument</code> <code>str</code> <p>Type of financial instrument. Default is \"Zero\".</p> <code>'Zero'</code> <code>liquid_maturities</code> <code>list</code> <p>Liquid maturities.</p> <code>[]</code> <code>RatesIn</code> <code>dict</code> <p>Input dictionary for RatesIn.</p> <code>{}</code> <code>nrofcoup</code> <code>int</code> <p>Number of Coupon Payments per Year. Default is 1.</p> <code>1</code> <code>cra</code> <code>float</code> <p>Credit Risk Adjustment in basispoints. Default is 0.</p> <code>0</code> <code>ufr</code> <code>float</code> <p>Ultimate Forward Rate annual compounded (perunage). Default is 0.</p> <code>0</code> <code>min_alfa</code> <code>float</code> <p>Minimum value for alfa. Default is 0.05.</p> <code>0.05</code> <code>tau</code> <code>float</code> <p>Tau value. Default is 1.</p> <code>1</code> <code>T2</code> <code>int</code> <p>Convergence Maturity. Default is 60.</p> <code>60</code> <code>precision</code> <code>int</code> <p>Precision value. Default is 6.</p> <code>6</code> <code>method</code> <code>str</code> <p>Calculation method. Default is \"brute_force\".</p> <code>'brute_force'</code> <code>output_type</code> <code>str</code> <p>Type of output. Default is \"zero rates annual compounding\".</p> <code>'zero rates annual compounding'</code> <p>Returns:</p> Name Type Description <code>output</code> <p>Calculated output based on the specified parameters.</p> Example <p>instrument = \"Zero\" liquid_maturities = [1, 2, 3, 4, 5] RatesIn = {0: 0.02, 1: 0.025, 2: 0.03, 3: 0.035, 4: 0.04, 5: 0.045} nrofcoup = 2 cra = 0.01 ufr = 0.05 min_alfa = 0.05 tau = 1 T2 = 60 precision = 6 method = \"brute_force\" output_type = \"zero rates annual compounding\" smith_wilson(instrument, liquid_maturities, RatesIn, nrofcoup, cra, ufr, min_alfa, tau, T2, precision, method, output_type) array([0.        , 0.01984642, 0.04040711, 0.06171705, 0.08381221,        0.10672926, 0.13050535, 0.15517806, 0.18078504, 0.20736481,        0.23495648, 0.26360038, 0.29333873, 0.3242144 , 0.35627157,        0.3895553 , 0.42411294, 0.4599934 , 0.49724737, 0.53592752,        0.57608986, 0.61779295, 0.66109833, 0.70607181, 0.75278461,        0.80131366, 0.85174183, 0.90415729, 0.95865366, 1.01533039,        1.0742924 , 1.13564943, 1.19951555, 1.26601055, 1.33526045,        1.40739786, 1.48256135, 1.5608958 , 1.6425528 , 1.72769014,        1.81647324, 1.90907556, 2.00567914, 2.10647707, 2.21167306,        2.32148215, 2.43613139, 2.55586064, 2.68092039, 2.81157657,        2.94810739, 3.09080731, 3.23998602, 3.39596949, 3.559099  ,        3.72973118, 3.90823814, 4.09500861, 4.29045285, 4.49400082,        4.70510529, 4.92324198, 5.14791281, 5.37864303, 5.61498852,        5.85652901, 6.10287445, 6.35366537, 6.6085712 , 6.86728774,        7.12954064, 7.395082  , 7.66368905, 7.93516083, 8.20931788,        8.48599994, 8.76506649, 9.04639664, 9.329887  , 9.61545067,        9.90301596, 10.19252555, 10.48393262, 10.77720086, 11.07230382,        11.36922416, 11.66795383, 11.96849432, 12.27085209, 12.57503994,        12.88007745, 13.18599135, 13.49281377, 13.80058263, 14.109341  ,        14.41913647, 14.73002158, 15.04205535, 15.35530365, 15.66983964,        15.98574325, 16.30310069, 16.62199494, 16.94251238, 17.2647438 ,        17.5887832 , 17.91472858, 18.24268076, 18.5727421 , 18.90502131,        19.23963426, 19.57670285, 19.9163558 , 20.25872748, 20.60395864,        20.95219615, 21.30359381, 21.65831201, 22.01651854, 22.3783874 ])</p> Source code in <code>solvency2_data\\smith_wilson.py</code> <pre><code>def smith_wilson(\n    instrument: str = \"Zero\",\n    liquid_maturities: list = [],\n    RatesIn: dict = {},\n    nrofcoup: int = 1,\n    cra: float = 0,\n    ufr: float = 0,\n    min_alfa: float = 0.05,\n    tau: float = 1,\n    T2: int = 60,\n    precision: int = 6,\n    method: str = \"brute_force\",\n    output_type: str = \"zero rates annual compounding\",\n):\n    \"\"\"\n    Calculates Smith-Wilson parameters and returns output based on the specified parameters.\n\n    Note: Prices of all instruments are set to 1 by construction.\n    Hence 1: if Instrument = Zero then for Zero i there is only one pay-off\n    of (1+r(i))^u(i) at time u(i).\n    Hence 2: if Instrument = Swap or Bond then for Swap/Bond i there are\n    pay-offs of r(i)/nrofcoup at time 1/nrofcoup, 2/nrofcoup, ...\n    u(i)-1/nrofcoup plus a final pay-off of 1+r(i)/nrofcoup at time u(i).\n\n    Args:\n        instrument (str): Type of financial instrument. Default is \"Zero\".\n        liquid_maturities (list): Liquid maturities.\n        RatesIn (dict): Input dictionary for RatesIn.\n        nrofcoup (int): Number of Coupon Payments per Year. Default is 1.\n        cra (float): Credit Risk Adjustment in basispoints. Default is 0.\n        ufr (float): Ultimate Forward Rate annual compounded (perunage). Default is 0.\n        min_alfa (float): Minimum value for alfa. Default is 0.05.\n        tau (float): Tau value. Default is 1.\n        T2 (int): Convergence Maturity. Default is 60.\n        precision (int): Precision value. Default is 6.\n        method (str): Calculation method. Default is \"brute_force\".\n        output_type (str): Type of output. Default is \"zero rates annual compounding\".\n\n    Returns:\n        output: Calculated output based on the specified parameters.\n\n    Example:\n        &gt;&gt;&gt; instrument = \"Zero\"\n        &gt;&gt;&gt; liquid_maturities = [1, 2, 3, 4, 5]\n        &gt;&gt;&gt; RatesIn = {0: 0.02, 1: 0.025, 2: 0.03, 3: 0.035, 4: 0.04, 5: 0.045}\n        &gt;&gt;&gt; nrofcoup = 2\n        &gt;&gt;&gt; cra = 0.01\n        &gt;&gt;&gt; ufr = 0.05\n        &gt;&gt;&gt; min_alfa = 0.05\n        &gt;&gt;&gt; tau = 1\n        &gt;&gt;&gt; T2 = 60\n        &gt;&gt;&gt; precision = 6\n        &gt;&gt;&gt; method = \"brute_force\"\n        &gt;&gt;&gt; output_type = \"zero rates annual compounding\"\n        &gt;&gt;&gt; smith_wilson(instrument, liquid_maturities, RatesIn, nrofcoup, cra, ufr, min_alfa, tau, T2, precision, method, output_type)\n        array([0.        , 0.01984642, 0.04040711, 0.06171705, 0.08381221,\n               0.10672926, 0.13050535, 0.15517806, 0.18078504, 0.20736481,\n               0.23495648, 0.26360038, 0.29333873, 0.3242144 , 0.35627157,\n               0.3895553 , 0.42411294, 0.4599934 , 0.49724737, 0.53592752,\n               0.57608986, 0.61779295, 0.66109833, 0.70607181, 0.75278461,\n               0.80131366, 0.85174183, 0.90415729, 0.95865366, 1.01533039,\n               1.0742924 , 1.13564943, 1.19951555, 1.26601055, 1.33526045,\n               1.40739786, 1.48256135, 1.5608958 , 1.6425528 , 1.72769014,\n               1.81647324, 1.90907556, 2.00567914, 2.10647707, 2.21167306,\n               2.32148215, 2.43613139, 2.55586064, 2.68092039, 2.81157657,\n               2.94810739, 3.09080731, 3.23998602, 3.39596949, 3.559099  ,\n               3.72973118, 3.90823814, 4.09500861, 4.29045285, 4.49400082,\n               4.70510529, 4.92324198, 5.14791281, 5.37864303, 5.61498852,\n               5.85652901, 6.10287445, 6.35366537, 6.6085712 , 6.86728774,\n               7.12954064, 7.395082  , 7.66368905, 7.93516083, 8.20931788,\n               8.48599994, 8.76506649, 9.04639664, 9.329887  , 9.61545067,\n               9.90301596, 10.19252555, 10.48393262, 10.77720086, 11.07230382,\n               11.36922416, 11.66795383, 11.96849432, 12.27085209, 12.57503994,\n               12.88007745, 13.18599135, 13.49281377, 13.80058263, 14.109341  ,\n               14.41913647, 14.73002158, 15.04205535, 15.35530365, 15.66983964,\n               15.98574325, 16.30310069, 16.62199494, 16.94251238, 17.2647438 ,\n               17.5887832 , 17.91472858, 18.24268076, 18.5727421 , 18.90502131,\n               19.23963426, 19.57670285, 19.9163558 , 20.25872748, 20.60395864,\n               20.95219615, 21.30359381, 21.65831201, 22.01651854, 22.3783874 ])\n    \"\"\"\n    assert (\n        instrument == \"Zero\" and nrofcoup == 1\n    ), \"instrument is zero bond, but with nrofcoup unequal to 1.\"\n    assert method == \"brute_force\", \"Only brute force method is implemented.\"\n    assert instrument == \"Zero\", \"No other instruments implemented yet.\"\n\n    # the number of liquid rates\n    n = len(liquid_maturities)\n    # nrofcoup * maximum liquid maturity\n    m = nrofcoup * max(liquid_maturities)\n\n    log_ufr = np.log(1 + ufr)\n    tau = tau / 10000\n    cra = cra / 10000\n\n    # Q' matrix according to 146 of specs;\n    q = q_matrix(instrument, n, m, liquid_maturities, RatesIn, nrofcoup, cra, log_ufr)\n\n    # Determine optimal alfa with corresponding gamma\n    if method == \"brute_force\":\n        alfa, gamma = optimal_alfa(min_alfa, q, nrofcoup, T2, tau, precision)\n    alfa = np.round(alfa, 6)\n\n    # Now the SW-present value function according to 154 of the specs can be\n    # calculated: p(v)=exp(-lnUFR*v)*(1+H(v,u)*Qb)\n    # The G(v,u) matrix for maturities v = 1 to 121 according to 142 of the\n    # technical specs (Note: maturity 121 will not be used; see later)\n    g = np.fromfunction(\n        lambda i, j: np.where(\n            j / nrofcoup &gt; i,\n            alfa * (1 - np.exp(-alfa * j / nrofcoup) * np.cosh(alfa * i)),\n            alfa * np.exp(-alfa * i) * np.sinh(alfa * j / nrofcoup),\n        ),\n        (121, m),\n    )\n\n    # The H(v,u) matrix for maturities v = 1 to 121 according to 139\n    # of the technical specs\n    # h[i, j] = big_h(alfa * i, alfa * (j+1) / nrofcoup) -&gt; strange,\n    # is different from earlier def\n    h = np.fromfunction(\n        lambda i, j: big_h(alfa * i / nrofcoup, alfa * (j + 1) / nrofcoup), (122, m)\n    )\n\n    # First a temporary discount-vector will be used to store the in-between\n    # result H(v,u)*Qb = #(v,u)*gamma (see 154 of the specs)\n    temptempdiscount = np.matmul(h, gamma)\n    # Calculating G(v,u)*Qb according to 158 of the specs\n    temptempintensity = np.matmul(g, gamma)\n\n    tempdiscount = np.zeros(121)\n    tempintensity = np.zeros(121)\n    for i in range(0, 121):\n        tempdiscount[i] = temptempdiscount[i][0]\n        tempintensity[i] = temptempintensity[i][0]\n\n    # calculating (1'-exp(-alfa*u'))Qb as subresult for 160 of specs\n    res1 = sum(\n        (1 - np.exp(-alfa * (i + 1) / nrofcoup)) * gamma[i, 0] for i in range(0, m)\n    )\n\n    # yield intensities\n    yldintensity = np.zeros(121)\n    yldintensity[0] = log_ufr - alfa * res1  # calculating 160 of the specs\n    # calculating 158 of the specs for maturity 1 year\n    yldintensity[1:] = log_ufr - np.log(1 + tempdiscount[1:]) / np.arange(1, 121)\n\n    # forward intensities # calculating 158 of the specs for higher maturities\n    fwintensity = np.zeros(121)\n    fwintensity[0] = log_ufr - alfa * res1  # calculating 160 of the specs\n    fwintensity[1:] = log_ufr - tempintensity[1:] / (1 + tempdiscount[1:])\n\n    # discount rates\n    discount = np.zeros(121)\n    discount[0] = 1\n    discount[1:] = np.exp(-log_ufr * np.arange(1, 121)) * (1 + tempdiscount[1:])\n\n    # forward rates annual compounding\n    forwardac = np.zeros(121)\n    forwardac[0] = 0\n    forwardac[1:] = discount[:-1] / discount[1:] - 1\n\n    # zero rates annual compounding\n    zeroac = np.zeros(121)\n    zeroac[0] = 0\n    zeroac[1:] = np.power(discount[1:], -1 / np.arange(1, 121)) - 1\n\n    if output_type == \"zero rates annual compounding\":\n        output = zeroac\n    elif output_type == \"forward rate annual compounding\":\n        output = forwardac\n    elif output_type == \"discount rates\":\n        output = discount\n    elif output_type == \"forward intensities\":\n        output = fwintensity\n    elif output_type == \"yield intensities\":\n        output = yldintensity\n    elif output_type == \"alfa\":\n        output = alfa\n\n    return output\n</code></pre> <p>Common utilities shared across modules</p>"},{"location":"api_docs/#solvency2_data.rfr.RFR_dict","title":"<code>RFR_dict(input_date=None, cache={})</code>","text":"<p>Generates a dictionary containing filenames based on the reference date and other data derived from it.</p> <p>Parameters:</p> Name Type Description Default <code>input_date</code> <code>str</code> <p>The input date in the format \"%Y-%m-%d\". Defaults to None, which means the current date is used.</p> <code>None</code> <code>cache</code> <code>dict</code> <p>A dictionary to store intermediate and final results. Defaults to an empty dictionary.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing generated filenames and other data. The dictionary includes the following keys:     - \"input_date\": The input date in the format \"%Y-%m-%d\".     - \"reference_date\": The reference date in the format \"%Y%m%d\".     - \"name_excelfile\": The filename for the EIOPA RFR term structures Excel file.     - \"name_excelfile_spreads\": The filename for the EIOPA RFR PD Cod Excel file.</p> Source code in <code>solvency2_data\\rfr.py</code> <pre><code>def RFR_dict(input_date: str = None, cache: dict = {}) -&gt; dict:\n    \"\"\"\n    Generates a dictionary containing filenames based on the reference date\n    and other data derived from it.\n\n    Args:\n        input_date (str, optional): The input date in the format \"%Y-%m-%d\".\n            Defaults to None, which means the current date is used.\n        cache (dict, optional): A dictionary to store intermediate and final results.\n            Defaults to an empty dictionary.\n\n    Returns:\n        dict: A dictionary containing generated filenames and other data.\n            The dictionary includes the following keys:\n                - \"input_date\": The input date in the format \"%Y-%m-%d\".\n                - \"reference_date\": The reference date in the format \"%Y%m%d\".\n                - \"name_excelfile\": The filename for the EIOPA RFR term structures Excel file.\n                - \"name_excelfile_spreads\": The filename for the EIOPA RFR PD Cod Excel file.\n    \"\"\"\n    cache = RFR_reference_date(input_date, cache)\n    cache[\"name_excelfile\"] = (\n        \"EIOPA_RFR_\" + cache[\"reference_date\"] + \"_Term_Structures\" + \".xlsx\"\n    )\n    cache[\"name_excelfile_spreads\"] = (\n        \"EIOPA_RFR_\" + cache[\"reference_date\"] + \"_PD_Cod\" + \".xlsx\"\n    )\n    return cache\n</code></pre>"},{"location":"api_docs/#solvency2_data.rfr.RFR_reference_date","title":"<code>RFR_reference_date(input_date=None, cache={})</code>","text":"<p>Calculates the reference date based on the input date or the current date. If no input date is provided or if the input date is in the future, it defaults to the current date. If the current date is before the 5th of the month, it sets the reference date to the last day of the previous month. Otherwise, it sets the reference date to the next day after the input date.</p> <p>Parameters:</p> Name Type Description Default <code>input_date</code> <code>str</code> <p>The input date in the format \"%Y-%m-%d\". Defaults to None, which means the current date is used.</p> <code>None</code> <code>cache</code> <code>dict</code> <p>A dictionary to store the calculated reference date. Defaults to an empty dictionary.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the input date and the reference date. The input date is stored under the key \"input_date\" in the format \"%Y-%m-%d\". The reference date is stored under the key \"reference_date\" in the format \"%Y%m%d\".</p> Source code in <code>solvency2_data\\rfr.py</code> <pre><code>def RFR_reference_date(input_date: str = None, cache: dict = {}) -&gt; dict:\n    \"\"\"\n    Calculates the reference date based on the input date or the current date.\n    If no input date is provided or if the input date is in the future,\n    it defaults to the current date. If the current date is before the 5th of the month,\n    it sets the reference date to the last day of the previous month.\n    Otherwise, it sets the reference date to the next day after the input date.\n\n    Args:\n        input_date (str, optional): The input date in the format \"%Y-%m-%d\".\n            Defaults to None, which means the current date is used.\n        cache (dict, optional): A dictionary to store the calculated reference date.\n            Defaults to an empty dictionary.\n\n    Returns:\n        dict: A dictionary containing the input date and the reference date.\n            The input date is stored under the key \"input_date\" in the format \"%Y-%m-%d\".\n            The reference date is stored under the key \"reference_date\" in the format \"%Y%m%d\".\n    \"\"\"\n    if input_date is not None:\n        reference_date = datetime.datetime.strptime(input_date, \"%Y-%m-%d\")\n    else:\n        reference_date = None\n\n    if (reference_date is None) or (reference_date &gt; datetime.datetime.today()):\n        reference_date = datetime.datetime.today()\n\n        if reference_date.day &lt; 5:\n            reference_date = reference_date.replace(day=1) - datetime.timedelta(days=1)\n    else:\n        reference_date = reference_date + datetime.timedelta(days=1)\n\n    # to do : check if end of month\n    reference_date = reference_date.replace(day=1) - datetime.timedelta(days=1)\n\n    cache[\"input_date\"] = reference_date.strftime(\"%Y-%m-%d\")\n    cache[\"reference_date\"] = cache[\"input_date\"].replace(\"-\", \"\")\n\n    return cache\n</code></pre>"},{"location":"api_docs/#solvency2_data.rfr.download_RFR","title":"<code>download_RFR(input_date=None, cache={})</code>","text":"<p>Downloads EIOPA RFR (Risk-Free Rate) files for a given date and saves them locally.</p> <p>Parameters:</p> Name Type Description Default <code>input_date</code> <code>str</code> <p>The input date in the format \"%Y-%m-%d\". Defaults to None, which means the current date is used.</p> <code>None</code> <code>cache</code> <code>dict</code> <p>A dictionary to store intermediate and final results. Defaults to an empty dictionary.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing information about the downloaded files and paths. The dictionary includes the following keys:     - \"input_date\": The input date in the format \"%Y-%m-%d\".     - \"reference_date\": The reference date in the format \"%Y%m%d\".     - \"name_excelfile\": The filename for the downloaded EIOPA RFR term structures Excel file.     - \"name_excelfile_spreads\": The filename for the downloaded EIOPA RFR PD Cod Excel file.     - \"url\": The URL from which the files were downloaded.     - \"name_zipfile\": The name of the downloaded zip file.     - \"path_excelfile\": The path where the Excel files are saved.     - \"path_zipfile\": The path where the zip file is saved.</p> Source code in <code>solvency2_data\\rfr.py</code> <pre><code>def download_RFR(input_date: str = None, cache: dict = {}) -&gt; dict:\n    \"\"\"\n    Downloads EIOPA RFR (Risk-Free Rate) files for a given date and saves them locally.\n\n    Args:\n        input_date (str, optional): The input date in the format \"%Y-%m-%d\".\n            Defaults to None, which means the current date is used.\n        cache (dict, optional): A dictionary to store intermediate and final results.\n            Defaults to an empty dictionary.\n\n    Returns:\n        dict: A dictionary containing information about the downloaded files and paths.\n            The dictionary includes the following keys:\n                - \"input_date\": The input date in the format \"%Y-%m-%d\".\n                - \"reference_date\": The reference date in the format \"%Y%m%d\".\n                - \"name_excelfile\": The filename for the downloaded EIOPA RFR term structures Excel file.\n                - \"name_excelfile_spreads\": The filename for the downloaded EIOPA RFR PD Cod Excel file.\n                - \"url\": The URL from which the files were downloaded.\n                - \"name_zipfile\": The name of the downloaded zip file.\n                - \"path_excelfile\": The path where the Excel files are saved.\n                - \"path_zipfile\": The path where the zip file is saved.\n    \"\"\"\n    cache = RFR_dict(input_date, cache)\n\n    if not (\n        os.path.isfile(join(cache[\"path_excelfile\"], cache[\"name_excelfile\"]))\n    ) or not (\n        os.path.isfile(join(cache[\"path_excelfile\"], cache[\"name_excelfile_spreads\"]))\n    ):\n        # determine correct url and zipfile\n        cache[\"url\"] = eiopa_link(cache[\"input_date\"], data_type=\"rfr\")\n        cache[\"name_zipfile\"] = os.path.basename(cache[\"url\"]).split(\"filename=\")[-1]\n\n        # download file\n        request = urlopen(cache[\"url\"])\n\n        # save zip-file\n        output = open(join(cache[\"path_zipfile\"], cache[\"name_zipfile\"]), \"wb\")\n        output.write(request.read())\n        output.close()\n\n        name_excelfile = None\n        name_excelfile_spreads = None\n        zip_ref = zipfile.ZipFile(join(cache[\"path_zipfile\"], cache[\"name_zipfile\"]))\n        for idx, name in enumerate(zip_ref.namelist()):\n            if name.lower() == cache[\"name_excelfile\"].lower():\n                name_excelfile = name\n            if name.lower() == cache[\"name_excelfile_spreads\"].lower():\n                name_excelfile_spreads = name\n        if name_excelfile is not None:\n            zip_ref.extract(name_excelfile, cache[\"path_excelfile\"])\n        if name_excelfile_spreads is not None:\n            zip_ref.extract(name_excelfile_spreads, cache[\"path_excelfile\"])\n        zip_ref.close()\n\n        # remove zip file\n        # os.remove(cache['path_zipfile'] + cache[\"name_zipfile\"])\n\n    return cache\n</code></pre>"},{"location":"api_docs/#solvency2_data.rfr.read","title":"<code>read(input_date=None, path=None)</code>","text":"<p>Reads data from Excel files and stores it in a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>input_date</code> <code>str</code> <p>The input date in the format \"%Y-%m-%d\". Defaults to None, which means the current date is used.</p> <code>None</code> <code>path</code> <code>str</code> <p>The path to the directory containing Excel files. If None, it looks for .cfg files in the current directory or the package directory. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the read data. The dictionary includes various keys storing downloaded files, metadata, spot data, spreadsheets, etc.</p> Source code in <code>solvency2_data\\rfr.py</code> <pre><code>def read(input_date=None, path: str = None) -&gt; dict:\n    \"\"\"\n    Reads data from Excel files and stores it in a dictionary.\n\n    Args:\n        input_date (str, optional): The input date in the format \"%Y-%m-%d\".\n            Defaults to None, which means the current date is used.\n        path (str, optional): The path to the directory containing Excel files.\n            If None, it looks for .cfg files in the current directory or the package directory.\n            Defaults to None.\n\n    Returns:\n        dict: A dictionary containing the read data.\n            The dictionary includes various keys storing downloaded files, metadata, spot data, spreadsheets, etc.\n    \"\"\"\n    if path is None:\n        # look in current directory for .cfg file\n        # if not exists then take the .cfg file in the package directory\n        config = get_config().get(\"Directories\")\n\n        path_zipfile = config.get(\"zip_files\")\n        path_excelfile = config.get(\"excel_files\")\n    else:\n        path_zipfile = path\n        path_excelfile = path\n\n    cache = {\"path_zipfile\": path_zipfile, \"path_excelfile\": path_excelfile}\n\n    cache = download_RFR(input_date, cache)\n    xls = pd.ExcelFile(\n        join(cache[\"path_excelfile\"], cache[\"name_excelfile\"]), engine=\"openpyxl\"\n    )\n    cache = read_meta(xls, cache)\n    cache = read_spot(xls, cache)\n    xls_spreads = pd.ExcelFile(\n        join(cache[\"path_excelfile\"], cache[\"name_excelfile_spreads\"]),\n        engine=\"openpyxl\",\n    )\n    cache = read_spreads(xls_spreads, cache)\n    cache = read_govies(xls_spreads, cache)\n\n    xls.close()\n    xls_spreads.close()\n\n    return cache\n</code></pre>"},{"location":"api_docs/#solvency2_data.rfr.read_govies","title":"<code>read_govies(xls, cache={})</code>","text":"<p>Reads central government fundamental spreads from an Excel file and stores them in a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>xls</code> <p>An object representing the Excel file.</p> required <code>cache</code> <code>dict</code> <p>A dictionary to store the read spreadsheets. Defaults to an empty dictionary.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the read spreadsheets. The dictionary includes the following keys:     - \"central government fundamental spreads\": A DataFrame containing central government spreads. The DataFrame includes spreads for various financial attributes indexed by dates.</p> Source code in <code>solvency2_data\\rfr.py</code> <pre><code>def read_govies(xls, cache: dict = {}) -&gt; dict:\n    \"\"\"\n    Reads central government fundamental spreads from an Excel file and stores them in a dictionary.\n\n    Args:\n        xls : An object representing the Excel file.\n        cache (dict, optional): A dictionary to store the read spreadsheets.\n            Defaults to an empty dictionary.\n\n    Returns:\n        dict: A dictionary containing the read spreadsheets.\n            The dictionary includes the following keys:\n                - \"central government fundamental spreads\": A DataFrame containing central government spreads.\n            The DataFrame includes spreads for various financial attributes indexed by dates.\n    \"\"\"\n    cache[\"central government fundamental spreads\"] = None\n    for name in [\"FS_Govts\"]:\n        if name in xls.sheet_names:\n            df = pd.read_excel(\n                io=xls,\n                sheet_name=name,\n                usecols=\"B:AF\",\n                nrows=53,\n                index_col=0,\n                skiprows=9,\n            )\n            # This line introduces a dependency on the spots\n            # df.index = cache['RFR_spot_no_VA'].columns\n            cache[\"central government fundamental spreads\"] = df.T\n\n    return cache\n</code></pre>"},{"location":"api_docs/#solvency2_data.rfr.read_meta","title":"<code>read_meta(xls, cache={})</code>","text":"<p>Reads metadata from an Excel file and stores it in a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>xls</code> <p>An object representing the Excel file.</p> required <code>cache</code> <code>dict</code> <p>A dictionary to store the read metadata. Defaults to an empty dictionary.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the read metadata. The dictionary includes the following key:     - \"meta\": DataFrame containing metadata. The DataFrame includes metadata indexed by \"meta\" and may include information such as headers, column descriptions, and other relevant details.</p> Source code in <code>solvency2_data\\rfr.py</code> <pre><code>def read_meta(xls, cache: str = {}) -&gt; dict:\n    \"\"\"\n    Reads metadata from an Excel file and stores it in a dictionary.\n\n    Args:\n        xls : An object representing the Excel file.\n        cache (dict, optional): A dictionary to store the read metadata.\n            Defaults to an empty dictionary.\n\n    Returns:\n        dict: A dictionary containing the read metadata.\n            The dictionary includes the following key:\n                - \"meta\": DataFrame containing metadata.\n            The DataFrame includes metadata indexed by \"meta\" and may include information\n            such as headers, column descriptions, and other relevant details.\n    \"\"\"\n    df_meta = pd.read_excel(\n        xls, sheet_name=\"RFR_spot_with_VA\", header=1, index_col=1, skipfooter=150\n    )\n    # drop unnamed columns from the excel file\n    for col in df_meta.columns:\n        if \"Unnamed:\" in col:\n            df_meta = df_meta.drop(col, axis=1)\n\n    df_meta.loc[\"VA\", :].infer_objects(copy=False).fillna(0, inplace=True)\n    df_meta = df_meta.iloc[0:8]\n    df_meta.index.names = [\"meta\"]\n    df_meta.index = df_meta.index.fillna(\"Info\")\n\n    # Reference date is not strictly part of meta\n    # df_append = pd.DataFrame(index=['reference date'],\n    #                          columns=df_meta.columns)\n    # # df_append.loc['reference date'] = cache[\"reference_date\"]\n    # df_meta = df_meta.append(df_append)\n\n    cache[\"meta\"] = df_meta\n\n    return cache\n</code></pre>"},{"location":"api_docs/#solvency2_data.rfr.read_spot","title":"<code>read_spot(xls, cache={})</code>","text":"<p>Reads various spot data from an Excel file and stores them in a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>xls</code> <p>An object representing the Excel file.</p> required <code>cache</code> <code>dict</code> <p>A dictionary to store the read spot data. Defaults to an empty dictionary.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the read spot data. The dictionary includes the following keys:     - \"RFR_spot_no_VA\": DataFrame containing spot data without VA.     - \"RFR_spot_with_VA\": DataFrame containing spot data with VA.     - \"Spot_NO_VA_shock_UP\": DataFrame containing spot data without VA with UP shock.     - \"Spot_NO_VA_shock_DOWN\": DataFrame containing spot data without VA with DOWN shock.     - \"Spot_WITH_VA_shock_UP\": DataFrame containing spot data with VA with UP shock.     - \"Spot_WITH_VA_shock_DOWN\": DataFrame containing spot data with VA with DOWN shock. Each DataFrame contains spot data indexed by duration.</p> Source code in <code>solvency2_data\\rfr.py</code> <pre><code>def read_spot(xls, cache: dict = {}) -&gt; dict:\n    \"\"\"\n    Reads various spot data from an Excel file and stores them in a dictionary.\n\n    Args:\n        xls : An object representing the Excel file.\n        cache (dict, optional): A dictionary to store the read spot data.\n            Defaults to an empty dictionary.\n\n    Returns:\n        dict: A dictionary containing the read spot data.\n            The dictionary includes the following keys:\n                - \"RFR_spot_no_VA\": DataFrame containing spot data without VA.\n                - \"RFR_spot_with_VA\": DataFrame containing spot data with VA.\n                - \"Spot_NO_VA_shock_UP\": DataFrame containing spot data without VA with UP shock.\n                - \"Spot_NO_VA_shock_DOWN\": DataFrame containing spot data without VA with DOWN shock.\n                - \"Spot_WITH_VA_shock_UP\": DataFrame containing spot data with VA with UP shock.\n                - \"Spot_WITH_VA_shock_DOWN\": DataFrame containing spot data with VA with DOWN shock.\n            Each DataFrame contains spot data indexed by duration.\n    \"\"\"\n    for name in [\n        \"RFR_spot_no_VA\",\n        \"RFR_spot_with_VA\",\n        \"Spot_NO_VA_shock_UP\",\n        \"Spot_NO_VA_shock_DOWN\",\n        \"Spot_WITH_VA_shock_UP\",\n        \"Spot_WITH_VA_shock_DOWN\",\n    ]:\n        if name in xls.sheet_names:\n            df = pd.read_excel(\n                io=xls, sheet_name=name, header=1, nrows=158, index_col=1\n            )\n            # drop unnamed columns from the excel file\n            for col in df.columns:\n                if \"Unnamed:\" in col:\n                    df = df.drop(col, axis=1)\n            df.loc[\"VA\"].infer_objects(copy=False).fillna(0, inplace=True)\n            df = df.iloc[8:]\n            df.index.names = [\"Duration\"]\n            cache[name] = df\n\n    return cache\n</code></pre>"},{"location":"api_docs/#solvency2_data.rfr.read_spreads","title":"<code>read_spreads(xls, cache={})</code>","text":"<p>Reads financial and non-financial fundamental spreads from an Excel file and stores them in a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>xls</code> <code>ExcelFile</code> <p>An ExcelFile object containing the spreadsheets.</p> required <code>cache</code> <code>dict</code> <p>A dictionary to store the read spreadsheets. Defaults to an empty dictionary.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the read spreadsheets. The dictionary includes the following keys:     - \"financial fundamental spreads\": A dictionary containing financial spreadsheets         for different currencies.     - \"non-financial fundamental spreads\": A dictionary containing non-financial spreadsheets         for different currencies. Each sub-dictionary contains DataFrames with financial or non-financial spreads for the respective currencies.</p> Source code in <code>solvency2_data\\rfr.py</code> <pre><code>def read_spreads(xls: pd.ExcelFile, cache: dict = {}) -&gt; dict:\n    \"\"\"\n    Reads financial and non-financial fundamental spreads from an Excel file and stores them in a dictionary.\n\n    Args:\n        xls (pd.ExcelFile): An ExcelFile object containing the spreadsheets.\n        cache (dict, optional): A dictionary to store the read spreadsheets.\n            Defaults to an empty dictionary.\n\n    Returns:\n        dict: A dictionary containing the read spreadsheets.\n            The dictionary includes the following keys:\n                - \"financial fundamental spreads\": A dictionary containing financial spreadsheets\n                    for different currencies.\n                - \"non-financial fundamental spreads\": A dictionary containing non-financial spreadsheets\n                    for different currencies.\n            Each sub-dictionary contains DataFrames with financial or non-financial spreads\n            for the respective currencies.\n    \"\"\"\n    cache[\"financial fundamental spreads\"] = {}\n    for name in currencies:\n        if name in xls.sheet_names:\n            df = pd.read_excel(\n                io=xls,\n                sheet_name=name,\n                header=1,\n                usecols=\"W:AC\",\n                nrows=30,\n                skiprows=8,\n                names=[0, 1, 2, 3, 4, 5, 6],\n            )\n            df.index = range(1, 31)\n            cache[\"financial fundamental spreads\"][name] = df\n\n    cache[\"non-financial fundamental spreads\"] = {}\n    for name in currencies:\n        if name in xls.sheet_names:\n            df = pd.read_excel(\n                io=xls,\n                sheet_name=name,\n                header=1,\n                usecols=\"W:AC\",\n                nrows=30,\n                skiprows=48,\n                names=[0, 1, 2, 3, 4, 5, 6],\n            )\n            df.index = range(1, 31)\n            cache[\"non-financial fundamental spreads\"][name] = df\n\n    return cache\n</code></pre>"},{"location":"api_docs/#solvency2_data.eiopa_data.add_to_db","title":"<code>add_to_db(ref_date, db, data_type='rfr', workspace=None)</code>","text":"<p>Adds data to the EIOPA database, to use when you are missing data.</p> <p>Parameters:</p> Name Type Description Default <code>ref_date</code> <code>str</code> <p>The reference date in the format \"%Y-%m-%d\".</p> required <code>db</code> <code>EiopaDB</code> <p>The EIOPA database instance.</p> required <code>data_type</code> <code>str</code> <p>The type of data to add. Options: \"rfr\" (default), \"meta\", \"spreads\", \"govies\", \"sym_adj\".</p> <code>'rfr'</code> <code>workspace</code> <code>dict</code> <p>A dictionary containing workspace directories and paths. If None, it retrieves workspace information using get_workspace() function. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>solvency2_data\\eiopa_data.py</code> <pre><code>def add_to_db(\n    ref_date: str, db: EiopaDB, data_type: str = \"rfr\", workspace: dict = None\n):\n    \"\"\"\n    Adds data to the EIOPA database, to use when you are missing data.\n\n    Args:\n        ref_date (str): The reference date in the format \"%Y-%m-%d\".\n        db (EiopaDB): The EIOPA database instance.\n        data_type (str, optional): The type of data to add.\n            Options: \"rfr\" (default), \"meta\", \"spreads\", \"govies\", \"sym_adj\".\n        workspace (dict, optional): A dictionary containing workspace directories and paths.\n            If None, it retrieves workspace information using get_workspace() function.\n            Defaults to None.\n\n    Returns:\n        None\n    \"\"\"\n    url = eiopa_link(ref_date, data_type=data_type)\n    set_id = db.get_set_id(url)\n\n    if data_type != \"sym_adj\":\n        files = download_EIOPA_rates(url, ref_date)\n        if data_type == \"rfr\":\n            df = extract_spot_rates(files[data_type])\n        elif data_type == \"meta\":\n            df = extract_meta(files[data_type])\n        elif data_type == \"spreads\":\n            df = extract_spreads(files[data_type])\n        elif data_type == \"govies\":\n            df = extract_govies(files[data_type])\n        else:\n            raise KeyError\n    elif data_type == \"sym_adj\":\n        if workspace is None:\n            workspace = get_workspace()\n        raw_folder = workspace[\"raw_data\"]\n        file = download_file(url, raw_folder)\n        df = extract_sym_adj(file, ref_date)\n\n    if df is not None:\n        df = df.reset_index()\n        df[\"url_id\"] = set_id\n        df[\"ref_date\"] = ref_date\n        df.to_sql(data_type, con=db.conn, if_exists=\"append\", index=False)\n        set_types = {\"govies\": \"rfr\", \"spreads\": \"rfr\", \"meta\": \"rfr\"}\n        db.update_catalog(\n            url_id=set_id,\n            dict_vals={\n                \"set_type\": set_types.get(data_type, data_type),\n                \"primary_set\": True,\n                \"ref_date\": ref_date,\n            },\n        )\n    return None\n</code></pre>"},{"location":"api_docs/#solvency2_data.eiopa_data.download_EIOPA_rates","title":"<code>download_EIOPA_rates(url, ref_date, workspace=None)</code>","text":"<p>Downloads EIOPA RFR (Risk-Free Rate) files from a given URL and extracts them.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL from which to download the EIOPA RFR files.</p> required <code>ref_date</code> <code>str</code> <p>The reference date in the format \"%Y-%m-%d\".</p> required <code>workspace</code> <code>dict</code> <p>A dictionary containing workspace directories and paths. If None, it retrieves workspace information using get_workspace() function. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the paths to the downloaded files. The dictionary includes the following keys:     - \"rfr\": The path to the downloaded EIOPA RFR term structures Excel file.     - \"meta\": The path to the downloaded EIOPA RFR meta Excel file.     - \"spreads\": The path to the downloaded EIOPA RFR PD Cod Excel file.     - \"govies\": The path to the downloaded EIOPA RFR govvies Excel file.</p> Source code in <code>solvency2_data\\eiopa_data.py</code> <pre><code>def download_EIOPA_rates(url: str, ref_date: str, workspace: dict = None) -&gt; dict:\n    \"\"\"\n    Downloads EIOPA RFR (Risk-Free Rate) files from a given URL and extracts them.\n\n    Args:\n        url (str): The URL from which to download the EIOPA RFR files.\n        ref_date (str): The reference date in the format \"%Y-%m-%d\".\n        workspace (dict, optional): A dictionary containing workspace directories and paths.\n            If None, it retrieves workspace information using get_workspace() function.\n            Defaults to None.\n\n    Returns:\n        dict: A dictionary containing the paths to the downloaded files.\n            The dictionary includes the following keys:\n                - \"rfr\": The path to the downloaded EIOPA RFR term structures Excel file.\n                - \"meta\": The path to the downloaded EIOPA RFR meta Excel file.\n                - \"spreads\": The path to the downloaded EIOPA RFR PD Cod Excel file.\n                - \"govies\": The path to the downloaded EIOPA RFR govvies Excel file.\n    \"\"\"\n    if workspace is None:\n        workspace = get_workspace()\n    raw_folder = workspace[\"raw_data\"]\n    zip_file = download_file(url, raw_folder)\n\n    # Change format of ref_date string for EIOPA Excel files from YYYY-mm-dd to YYYYmmdd:\n    reference_date = ref_date.replace(\"-\", \"\")\n\n    name_excelfile = \"EIOPA_RFR_\" + reference_date + \"_Term_Structures\" + \".xlsx\"\n    name_excelfile_spreads = \"EIOPA_RFR_\" + reference_date + \"_PD_Cod\" + \".xlsx\"\n    # Making file paths string insensitve via regex\n    re_rfr = re.compile(f\"(?i:{name_excelfile})\")\n    re_spreads = re.compile(f\"(?i:{name_excelfile_spreads})\")\n\n    with zipfile.ZipFile(zip_file) as zipobj:\n        for file in zipobj.namelist():\n            res_rfr = re_rfr.search(file)\n            res_spreads = re_spreads.search(file)\n            if res_rfr:\n                rfr_file = res_rfr.group(0)\n                zipobj.extract(rfr_file, raw_folder)\n            if res_spreads:\n                spreads_file = res_spreads.group(0)\n                zipobj.extract(spreads_file, raw_folder)\n    return {\n        \"rfr\": os.path.join(raw_folder, name_excelfile),\n        \"meta\": os.path.join(raw_folder, name_excelfile),\n        \"spreads\": os.path.join(raw_folder, name_excelfile_spreads),\n        \"govies\": os.path.join(raw_folder, name_excelfile_spreads),\n    }\n</code></pre>"},{"location":"api_docs/#solvency2_data.eiopa_data.download_file","title":"<code>download_file(url, raw_folder, filename='')</code>","text":"<p>Downloads a file from a URL and saves it in a specified folder.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the file to download.</p> required <code>raw_folder</code> <code>str</code> <p>The path to the directory where the file will be saved.</p> required <code>filename</code> <code>str</code> <p>The desired filename. If not provided, the filename will be derived from the URL. Defaults to \"\".</p> <code>''</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The path to the downloaded file.</p> Source code in <code>solvency2_data\\eiopa_data.py</code> <pre><code>def download_file(url: str, raw_folder: str, filename: str = \"\") -&gt; str:\n    \"\"\"\n    Downloads a file from a URL and saves it in a specified folder.\n\n    Args:\n        url (str): The URL of the file to download.\n        raw_folder (str): The path to the directory where the file will be saved.\n        filename (str, optional): The desired filename. If not provided,\n            the filename will be derived from the URL. Defaults to \"\".\n\n    Returns:\n        str: The path to the downloaded file.\n    \"\"\"\n    if filename:\n        extension = url[(url.rfind(\".\")) :]\n        if extension not in filename:\n            filename = filename + extension\n        else:\n            pass\n    else:\n        # if filename not specified, then the file name will be the original file name\n        filename = url[(url.rfind(\"/\") + 1) :]\n        # make sure that the filename does not contain illegal characters\n        filename = re.sub(r\"[^\\w_. -]\", \"_\", filename)\n\n    if filename[-4:] != \".zip\":\n        filename = filename + \".zip\"\n\n    target_file = os.path.join(raw_folder, filename)\n\n    if os.path.isfile(target_file):\n        logging.info(\"file already exists in this location, not downloading\")\n    else:\n        if not os.path.exists(raw_folder):\n            os.makedirs(raw_folder)\n        urllib.request.urlretrieve(url, target_file)  # simpler for file downloading\n        logging.info(\n            \"file downloaded and saved in the following location: \" + target_file\n        )\n\n    return target_file\n</code></pre>"},{"location":"api_docs/#solvency2_data.eiopa_data.extract_govies","title":"<code>extract_govies(govies_filepath)</code>","text":"<p>Extracts government spreads data from an EIOPA RFR spreads Excel file.</p> <p>Parameters:</p> Name Type Description Default <code>govies_filepath</code> <code>str</code> <p>The path to the EIOPA RFR spreads Excel file containing government spreads.</p> required <p>Returns:</p> Type Description <p>pandas.DataFrame or None: A DataFrame containing extracted government spreads data, indexed by country code and duration. Returns None if no government spreads are found.</p> Source code in <code>solvency2_data\\eiopa_data.py</code> <pre><code>def extract_govies(govies_filepath):\n    \"\"\"\n    Extracts government spreads data from an EIOPA RFR spreads Excel file.\n\n    Args:\n        govies_filepath (str): The path to the EIOPA RFR spreads Excel file containing government spreads.\n\n    Returns:\n        pandas.DataFrame or None: A DataFrame containing extracted government spreads data,\n            indexed by country code and duration.\n            Returns None if no government spreads are found.\n    \"\"\"\n    logging.info(\"Extracting govies: \" + govies_filepath)\n    xls = pd.ExcelFile(govies_filepath, engine=\"openpyxl\")\n    cache = read_govies(xls)\n    if cache[\"central government fundamental spreads\"] is not None:\n        spreads_gov = (\n            cache[\"central government fundamental spreads\"]\n            .stack()\n            .rename(\"spread\")\n            .to_frame()\n        )\n        spreads_gov.index.names = [\"duration\", \"country_code\"]\n        spreads_gov.index = spreads_gov.index.reorder_levels([1, 0])\n    else:\n        logging.error(\"No govies found: \" + govies_filepath)\n        spreads_gov = None\n    return spreads_gov\n</code></pre>"},{"location":"api_docs/#solvency2_data.eiopa_data.extract_meta","title":"<code>extract_meta(rfr_filepath)</code>","text":"<p>Extracts metadata from an EIOPA RFR Excel file.</p> <p>Parameters:</p> Name Type Description Default <code>rfr_filepath</code> <code>str</code> <p>The path to the EIOPA RFR Excel file.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing extracted metadata. The dictionary includes metadata indexed by country.</p> Source code in <code>solvency2_data\\eiopa_data.py</code> <pre><code>def extract_meta(rfr_filepath: str) -&gt; dict:\n    \"\"\"\n    Extracts metadata from an EIOPA RFR Excel file.\n\n    Args:\n        rfr_filepath (str): The path to the EIOPA RFR Excel file.\n\n    Returns:\n        dict: A dictionary containing extracted metadata.\n            The dictionary includes metadata indexed by country.\n    \"\"\"\n    logging.info(\"Extracting meta data :\" + rfr_filepath)\n    meta = read_meta(rfr_filepath)\n    meta = pd.concat(meta).T\n    meta.columns = meta.columns.droplevel()\n    meta.index.name = \"Country\"\n    meta = meta.sort_index()\n    return meta\n</code></pre>"},{"location":"api_docs/#solvency2_data.eiopa_data.extract_spot_rates","title":"<code>extract_spot_rates(rfr_filepath)</code>","text":"<p>Extracts spot rates from an EIOPA RFR Excel file.</p> <p>Parameters:</p> Name Type Description Default <code>rfr_filepath</code> <code>str</code> <p>The path to the EIOPA RFR Excel file.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing extracted spot rates. The dictionary includes spot rates indexed by scenario, currency code, and duration.</p> Source code in <code>solvency2_data\\eiopa_data.py</code> <pre><code>def extract_spot_rates(rfr_filepath: str) -&gt; dict:\n    \"\"\"\n    Extracts spot rates from an EIOPA RFR Excel file.\n\n    Args:\n        rfr_filepath (str): The path to the EIOPA RFR Excel file.\n\n    Returns:\n        dict: A dictionary containing extracted spot rates.\n            The dictionary includes spot rates indexed by scenario, currency code, and duration.\n    \"\"\"\n    logging.info(\"Extracting spots: \" + rfr_filepath)\n    # TODO: Complete this remap dictionary\n    currency_codes_and_regions = {\n        \"EUR\": \"Euro\",\n        \"PLN\": \"Poland\",\n        \"CHF\": \"Switzerland\",\n        \"USD\": \"United States\",\n        \"GBP\": \"United Kingdom\",\n        \"NOK\": \"Norway\",\n        \"SEK\": \"Sweden\",\n        \"DKK\": \"Denmark\",\n        \"HRK\": \"Croatia\",\n    }\n    currency_dict = dict((v, k) for k, v in currency_codes_and_regions.items())\n\n    xls = pd.ExcelFile(rfr_filepath, engine=\"openpyxl\")\n    rates_tables = read_spot(xls)\n\n    rates_tables = pd.concat(rates_tables)\n    rates_tables = rates_tables.rename(columns=currency_dict)[currency_dict.values()]\n\n    label_remap = {\n        \"RFR_spot_no_VA\": \"base\",\n        \"RFR_spot_with_VA\": \"va\",\n        \"Spot_NO_VA_shock_UP\": \"up\",\n        \"Spot_NO_VA_shock_DOWN\": \"down\",\n        \"Spot_WITH_VA_shock_UP\": \"va_up\",\n        \"Spot_WITH_VA_shock_DOWN\": \"va_down\",\n    }\n    rates_tables = rates_tables.rename(label_remap)\n\n    rates_tables = rates_tables.stack().rename(\"spot\")\n\n    rates_tables.index.names = [\"scenario\", \"duration\", \"currency_code\"]\n    rates_tables.index = rates_tables.index.reorder_levels([0, 2, 1])\n    rates_tables = rates_tables.sort_index()\n    return rates_tables\n</code></pre>"},{"location":"api_docs/#solvency2_data.eiopa_data.extract_spreads","title":"<code>extract_spreads(spread_filepath)</code>","text":"<p>Extracts spreads data from an EIOPA RFR spreads Excel file.</p> <p>Parameters:</p> Name Type Description Default <code>spread_filepath</code> <code>str</code> <p>The path to the EIOPA RFR spreads Excel file.</p> required <p>Returns:</p> Type Description <p>pandas.DataFrame: A DataFrame containing extracted spreads data. The DataFrame includes spreads indexed by type, currency code, credit curve step, and duration.</p> Source code in <code>solvency2_data\\eiopa_data.py</code> <pre><code>def extract_spreads(spread_filepath):\n    \"\"\"\n    Extracts spreads data from an EIOPA RFR spreads Excel file.\n\n    Args:\n        spread_filepath (str): The path to the EIOPA RFR spreads Excel file.\n\n    Returns:\n        pandas.DataFrame: A DataFrame containing extracted spreads data.\n            The DataFrame includes spreads indexed by type, currency code, credit curve step, and duration.\n    \"\"\"\n    logging.info(\"Extracting spreads: \" + spread_filepath)\n    xls = pd.ExcelFile(spread_filepath, engine=\"openpyxl\")\n    spreads = read_spreads(xls)\n    spreads_non_gov = pd.concat(\n        {\n            i: pd.concat(spreads[i])\n            for i in [\n                \"financial fundamental spreads\",\n                \"non-financial fundamental spreads\",\n            ]\n        }\n    )\n    spreads_non_gov = spreads_non_gov.stack().rename(\"spread\")\n    spreads_non_gov.index.names = [\"type\", \"currency_code\", \"duration\", \"cc_step\"]\n    spreads_non_gov.index = spreads_non_gov.index.reorder_levels([0, 1, 3, 2])\n    spreads_non_gov = spreads_non_gov.rename(\n        {\n            \"financial fundamental spreads\": \"fin\",\n            \"non-financial fundamental spreads\": \"non_fin\",\n        }\n    )\n    return spreads_non_gov\n</code></pre>"},{"location":"api_docs/#solvency2_data.eiopa_data.extract_sym_adj","title":"<code>extract_sym_adj(sym_adj_filepath, ref_date)</code>","text":"<p>Extracts symmetric adjustment data from a file.</p> <p>Parameters:</p> Name Type Description Default <code>sym_adj_filepath</code> <code>str</code> <p>The path to the file containing symmetric adjustment data.</p> required <code>ref_date</code> <code>str</code> <p>The reference date in the format \"%Y-%m-%d\".</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame or None: A DataFrame containing symmetric adjustment data. Returns None if there is a date mismatch between the reference date provided and the date in the file.</p> Source code in <code>solvency2_data\\eiopa_data.py</code> <pre><code>def extract_sym_adj(sym_adj_filepath: str, ref_date: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Extracts symmetric adjustment data from a file.\n\n    Args:\n        sym_adj_filepath (str): The path to the file containing symmetric adjustment data.\n        ref_date (str): The reference date in the format \"%Y-%m-%d\".\n\n    Returns:\n        pd.DataFrame or None: A DataFrame containing symmetric adjustment data.\n            Returns None if there is a date mismatch between the reference date provided\n            and the date in the file.\n    \"\"\"\n    df = pd.read_excel(\n        sym_adj_filepath,\n        sheet_name=\"Symmetric_adjustment\",\n        usecols=\"E, K\",\n        nrows=1,\n        skiprows=7,\n        header=None,\n        names=[\"ref_date\", \"sym_adj\"],\n    ).squeeze(\"columns\")\n\n    input_ref = ref_date\n    ref_check = df.at[0, \"ref_date\"].strftime(\"%Y-%m-%d\")\n\n    if input_ref != ref_check:\n        logging.warning(\"Date mismatch in sym_adj file: \" + sym_adj_filepath)\n        logging.warning(\n            \"Try opening this file and setting the date correctly then save and close, and rerun.\"\n        )\n        return None\n    else:\n        df = df.set_index(\"ref_date\")\n        return df\n</code></pre>"},{"location":"api_docs/#solvency2_data.eiopa_data.get","title":"<code>get(ref_date, data_type='rfr', workspace=None)</code>","text":"<p>Retrieves data from the EIOPA database for a given reference date and data type.</p> <p>Parameters:</p> Name Type Description Default <code>ref_date</code> <code>str</code> <p>The reference date in the format \"%Y-%m-%d\".</p> required <code>data_type</code> <code>str</code> <p>The type of data to retrieve. Options: \"rfr\" (default), \"meta\", \"spreads\", \"govies\", \"sym_adj\".</p> <code>'rfr'</code> <code>workspace</code> <code>dict</code> <p>A dictionary containing workspace directories and paths. If None, it retrieves workspace information using get_workspace() function. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>pandas.DataFrame or None: A DataFrame containing retrieved data. Returns None if no data is found for the given reference date and data type.</p> Source code in <code>solvency2_data\\eiopa_data.py</code> <pre><code>def get(ref_date: str, data_type: str = \"rfr\", workspace: dict = None):\n    \"\"\"\n    Retrieves data from the EIOPA database for a given reference date and data type.\n\n    Args:\n        ref_date (str): The reference date in the format \"%Y-%m-%d\".\n        data_type (str, optional): The type of data to retrieve.\n            Options: \"rfr\" (default), \"meta\", \"spreads\", \"govies\", \"sym_adj\".\n        workspace (dict, optional): A dictionary containing workspace directories and paths.\n            If None, it retrieves workspace information using get_workspace() function.\n            Defaults to None.\n\n    Returns:\n        pandas.DataFrame or None: A DataFrame containing retrieved data.\n            Returns None if no data is found for the given reference date and data type.\n    \"\"\"\n    # Validate the provided ref_date:\n    ref_date = validate_date_string(ref_date)\n    # Check if DB exists, if not, create it:\n    if workspace is None:\n        workspace = get_workspace()\n    database = workspace[\"database\"]\n    db = EiopaDB(database)\n\n    sql_map = {\n        \"rfr\": \"SELECT * FROM rfr WHERE ref_date = '\" + ref_date + \"'\",\n        \"meta\": \"SELECT * FROM meta WHERE ref_date = '\" + ref_date + \"'\",\n        \"spreads\": \"SELECT * FROM spreads WHERE ref_date = '\" + ref_date + \"'\",\n        \"govies\": \"SELECT * FROM govies WHERE ref_date = '\" + ref_date + \"'\",\n        \"sym_adj\": \"SELECT * FROM sym_adj WHERE ref_date = '\" + ref_date + \"'\",\n    }\n    sql = sql_map.get(data_type)\n    df = pd.read_sql(sql, con=db.conn)\n    if df.empty:\n        add_to_db(ref_date, db, data_type)\n        df = pd.read_sql(sql, con=db.conn)\n    if not df.empty:\n        df = df.drop(columns=[\"url_id\", \"ref_date\"])\n        return df\n    else:\n        return None\n</code></pre>"},{"location":"api_docs/#solvency2_data.eiopa_data.get_workspace","title":"<code>get_workspace()</code>","text":"<p>Retrieves workspace directories and paths from the configuration.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing workspace directories and paths. The dictionary includes the following keys:     - \"database\": The path to the EIOPA database file.     - \"raw_data\": The path to the directory containing raw data.</p> Source code in <code>solvency2_data\\eiopa_data.py</code> <pre><code>def get_workspace() -&gt; dict:\n    \"\"\"\n    Retrieves workspace directories and paths from the configuration.\n\n    Returns:\n        dict: A dictionary containing workspace directories and paths.\n            The dictionary includes the following keys:\n                - \"database\": The path to the EIOPA database file.\n                - \"raw_data\": The path to the directory containing raw data.\n    \"\"\"\n    config = get_config().get(\"Directories\")\n    path_db = config.get(\"db_folder\")\n    database = os.path.join(path_db, \"eiopa.db\")\n    path_raw = config.get(\"raw_data\")\n    return {\"database\": database, \"raw_data\": path_raw}\n</code></pre>"},{"location":"api_docs/#solvency2_data.eiopa_data.refresh","title":"<code>refresh()</code>","text":"<p>Refreshes the EIOPA database by updating data for each month from January 2016 to the current month.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>A message indicating that the database has been successfully rebuilt.</p> Source code in <code>solvency2_data\\eiopa_data.py</code> <pre><code>def refresh():\n    \"\"\"\n    Refreshes the EIOPA database by updating data for each month from January 2016 to the current month.\n\n    Returns:\n        str: A message indicating that the database has been successfully rebuilt.\n    \"\"\"\n    dr = pd.date_range(date(2016, 1, 31), date.today(), freq=\"M\")\n    # dr = pd.date_range(date(2021, 11, 30), date.today(), freq=\"M\")\n    for ref_date in dr:\n        for data_type in [\"rfr\", \"meta\", \"spreads\", \"govies\", \"sym_adj\"]:\n            _ = get(ref_date.date(), data_type)\n    return \"Database successfully rebuilt\"\n</code></pre>"},{"location":"api_docs/#solvency2_data.eiopa_data.validate_date_string","title":"<code>validate_date_string(ref_date)</code>","text":"<p>Validates the input date string.</p> <p>Parameters:</p> Name Type Description Default <code>ref_date</code> <code>str or date</code> <p>The input date string or datetime.date object.</p> required <p>Returns:</p> Type Description <p>str or None: A validated date string in the format \"%Y-%m-%d\". Returns None if the input date type is not recognized or cannot be converted.</p> Source code in <code>solvency2_data\\eiopa_data.py</code> <pre><code>def validate_date_string(ref_date):\n    \"\"\"\n    Validates the input date string.\n\n    Args:\n        ref_date (str or datetime.date): The input date string or datetime.date object.\n\n    Returns:\n        str or None: A validated date string in the format \"%Y-%m-%d\".\n            Returns None if the input date type is not recognized or cannot be converted.\n    \"\"\"\n    if type(ref_date) == datetime.date:\n        return ref_date.strftime(\"%Y-%m-%d\")\n    elif isinstance(ref_date, str):\n        try:\n            return datetime.datetime.strptime(ref_date, \"%Y-%m-%d\").strftime(\"%Y-%m-%d\")\n        except (TypeError, ValueError):\n            logging.warning(\"Date type not recognised. Try datetime.date or YYYY-mm-dd\")\n            return None\n    else:\n        return None\n</code></pre>"},{"location":"api_docs/#solvency2_data.scraping.check_if_download","title":"<code>check_if_download(url)</code>","text":"<p>Checks if the URL points to a downloadable resource.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the resource is downloadable, False otherwise.</p> Source code in <code>solvency2_data\\scraping.py</code> <pre><code>def check_if_download(url: str) -&gt; bool:\n    \"\"\"\n    Checks if the URL points to a downloadable resource.\n\n    Args:\n        url (str): The URL to check.\n\n    Returns:\n        bool: True if the resource is downloadable, False otherwise.\n    \"\"\"\n    headers = requests.head(url).headers\n    # downloadable = 'attachment' in headers.get('Content-Disposition', '')\n    downloadable = headers.get(\"Content-Type\") in [\n        \"application/zip\",\n        \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n    ]\n    return downloadable\n</code></pre>"},{"location":"api_docs/#solvency2_data.scraping.eiopa_link","title":"<code>eiopa_link(ref_date, data_type='rfr')</code>","text":"<p>Generates the link for downloading the selected type of data for a given date.</p> <p>Parameters:</p> Name Type Description Default <code>ref_date</code> <code>str</code> <p>The reference date in the format 'YYYY-MM-DD'.</p> required <code>data_type</code> <code>str</code> <p>The type of the dataset. Defaults to 'rfr'.</p> <code>'rfr'</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The valid link to the dataset.</p> Example <p>from datetime import date import pandas as pd dr = pd.date_range(date(2016, 1, 31), date(2023, 5, 31), freq='M') rfr_links = {i.strftime('%Y%m%d'): eiopa_link(i.strftime('%Y-%m-%d')) for i in dr} sym_adj_links = {i.strftime('%Y%m%d'): eiopa_link(i.strftime('%Y-%m-%d'), 'sym_adj') for i in dr}</p> Source code in <code>solvency2_data\\scraping.py</code> <pre><code>def eiopa_link(ref_date: str, data_type: str = \"rfr\") -&gt; str:\n    \"\"\"\n    Generates the link for downloading the selected type of data for a given date.\n\n    Args:\n        ref_date (str): The reference date in the format 'YYYY-MM-DD'.\n        data_type (str, optional): The type of the dataset. Defaults to 'rfr'.\n\n    Returns:\n        str: The valid link to the dataset.\n\n    Example:\n        from datetime import date\n        import pandas as pd\n        dr = pd.date_range(date(2016, 1, 31), date(2023, 5, 31), freq='M')\n        rfr_links = {i.strftime('%Y%m%d'): eiopa_link(i.strftime('%Y-%m-%d')) for i in dr}\n        sym_adj_links = {i.strftime('%Y%m%d'): eiopa_link(i.strftime('%Y-%m-%d'), 'sym_adj') for i in dr}\n    \"\"\"\n    data_type_remap = {\"spreads\": \"rfr\", \"govies\": \"rfr\", \"meta\": \"rfr\"}\n    data_type = data_type_remap.get(data_type, data_type)\n    urls = urls_dict.get(data_type)\n    # Change format of ref_date string for EIOPA Excel files from YYYY-mm-dd to YYYYmmdd:\n    reference_date = ref_date.replace(\"-\", \"\")\n    ref_date_datetime = datetime.datetime.strptime(ref_date, \"%Y-%m-%d\")\n    str_year = ref_date_datetime.strftime(\"%Y\")\n    str_month = ref_date_datetime.strftime(\"%B\").lower()\n    if data_type == \"rfr\":\n        # eiopa uses two naming conventions for the files\n        filename1 = (\n            \".*(?i:filename=)(?:%E2%80%8B)?\"\n            + \"(?i:\"\n            + str_month\n            + \")\"\n            + \"(?:[-, _]|%20)\"\n            + str_year\n            + \".*\"\n            \".*\"\n        )\n        filename2 = \".*EIOPA_RFR_\" + reference_date + \".zip\"\n        r = re.compile(filename1 + \"|\" + filename2)\n\n    elif data_type == \"sym_adj\":\n        # Regex to find the file :\n        # ._ required for ._march_2019\n        # Only matches on first 3 letters of months since some mis-spellings\n        words_in_link = [\"symmetric\", \"adjustment\", \"equity\", \"capital\", \"charge\"]\n        r = re.compile(\n            \".*(?i:eiopa)(?:[-, _]|%20)\"\n            + \"(?:[-, _]|%20)\".join(words_in_link)\n            + \"(?:[-, _]|%20)\"\n            + \"(?i:\"\n            + str_month[:3]\n            + \")\"\n            + \"[a-z]{0,\"\n            + str(len(str_month) - 3)\n            + \"}(?:[-, _]|%20)\"\n            + str_year\n            + \"(?:_[0-9]{0,1})?(?:.xlsx|$)\"\n        )\n\n    valid_link = get_links(urls, r)\n\n    problem_dates = {\"rfr\": [\"2021-11-30\"]}\n    if ref_date in problem_dates.get(data_type, []):\n        valid_link = False\n\n    if not valid_link:\n        manual_links = {\n            \"sym_adj\": {\n                \"2020-06-30\": \"https://www.eiopa.europa.eu/system/files/2020-06/eiopa_symmetric_adjustment_equity_capital_charge_16_06_2020.xlsx\",\n                \"2020-07-31\": \"https://www.eiopa.europa.eu/system/files/2020-07/eiopa_symmetric_adjustment_equity_capital_charge_14_07_2020.xlsx\",\n            },\n            \"rfr\": {\n                \"2021-11-30\": \"https://www.eiopa.europa.eu/system/files/2021-12/eiopa_rfr_20211130.zip\"\n            },\n        }\n        valid_link = manual_links.get(data_type).get(ref_date)\n\n    if not valid_link:\n        raise FileNotFoundError(\n            \"Error: no EIOPA file found for date: \"\n            + ref_date\n            + \"; Source: \"\n            + data_type\n        )\n\n    return valid_link\n</code></pre>"},{"location":"api_docs/#solvency2_data.scraping.get_links","title":"<code>get_links(urls, r)</code>","text":"<p>Retrieves valid download links from a list of URLs.</p> <p>Parameters:</p> Name Type Description Default <code>urls</code> <code>str</code> <p>A list of URLs to search for links.</p> required <code>r</code> <code>str</code> <p>The pattern to match for links.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of valid download links.</p> Source code in <code>solvency2_data\\scraping.py</code> <pre><code>def get_links(urls: str, r: str) -&gt; list:\n    \"\"\"\n    Retrieves valid download links from a list of URLs.\n\n    Args:\n        urls (str): A list of URLs to search for links.\n        r (str): The pattern to match for links.\n\n    Returns:\n        list: A list of valid download links.\n    \"\"\"\n    raw_links = []\n    for page in urls:\n        if len(raw_links) == 0:\n            resp = requests.get(page)\n            soup = bs.BeautifulSoup(resp.text, \"lxml\")\n            for link in soup.find_all(\"a\", {\"href\": r}):\n                if link.get(\"href\")[0] == \"/\":\n                    # correct relative urls\n                    link_before_redirect = \"https://www.eiopa.europa.eu\" + link.get(\n                        \"href\"\n                    )\n                else:\n                    link_before_redirect = link.get(\"href\")\n                # Check if there is a redirect:\n                raw_links.append(link_before_redirect)\n\n    valid_links = []\n    for url in raw_links:\n        if check_if_download(url):\n            valid_links.append(url)\n        else:\n            redirect = lookthrough_redirect(url)\n            if check_if_download(redirect):\n                valid_links.append(redirect)\n    if len(valid_links) &gt; 0:\n        return valid_links[0]\n    else:\n        return None\n</code></pre>"},{"location":"api_docs/#solvency2_data.scraping.lookthrough_redirect","title":"<code>lookthrough_redirect(url)</code>","text":"<p>Looks through redirects and returns the final URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to look through.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The final URL after following redirects.</p> Source code in <code>solvency2_data\\scraping.py</code> <pre><code>def lookthrough_redirect(url: str) -&gt; str:\n    \"\"\"\n    Looks through redirects and returns the final URL.\n\n    Args:\n        url (str): The URL to look through.\n\n    Returns:\n        str: The final URL after following redirects.\n    \"\"\"\n    try:\n        resp = urllib.request.urlopen(url)\n        file_url = resp.geturl()\n    except ImportError:\n        file_url = url\n    return file_url\n</code></pre>"},{"location":"api_docs/#solvency2_data.sqlite_handler.EiopaDB","title":"<code>EiopaDB</code>","text":"<p>             Bases: <code>object</code></p> <p>Database object to store the EIOPA data.</p> <p>Attributes:</p> Name Type Description <code>database</code> <code>str</code> <p>Path to the database file.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initialize database object.</p> <code>reset</code> <p>Hard reset of the database.</p> <code>set_conn</code> <p>Set database connection.</p> <code>_close_conn</code> <p>Close database connection.</p> <code>get_set_id</code> <p>Get the URL ID for a URL.</p> <code>_add_set</code> <p>Add a new URL to the catalog.</p> <code>update_catalog</code> <p>Update the catalog with new values.</p> Source code in <code>solvency2_data\\sqlite_handler.py</code> <pre><code>class EiopaDB(object):\n    \"\"\"\n    Database object to store the EIOPA data.\n\n    Attributes:\n        database (str): Path to the database file.\n\n    Methods:\n        __init__(database): Initialize database object.\n        reset(): Hard reset of the database.\n        set_conn(): Set database connection.\n        _close_conn(): Close database connection.\n        get_set_id(url): Get the URL ID for a URL.\n        _add_set(url): Add a new URL to the catalog.\n        update_catalog(url_id, dict_vals): Update the catalog with new values.\n    \"\"\"\n\n    def __init__(self, database):\n        \"\"\"\n        Initialize the database.\n\n        Args:\n            database (str): Path to the database file.\n\n        Returns:\n            None\n        \"\"\"\n        self.database = database\n        if not os.path.isfile(database):\n            root_folder = os.path.dirname(database)\n            if not os.path.exists(root_folder):\n                os.makedirs(root_folder)\n            create_eiopa_db(database)\n        self.set_conn()\n        logging.info(\"DB initialised\")\n\n    def reset(self):\n        \"\"\"\n        Hard reset of the database\n\n        Args:\n            None\n\n        Returns:\n            None\n\n        \"\"\"\n        if os.path.exists(self.database):\n            self._close_conn()\n            os.remove(self.database)\n        create_eiopa_db(self.database)\n        self.set_conn()\n\n    def set_conn(self):\n        \"\"\"\n        Set database connection\n\n        Args:\n            None\n\n        Returns:\n            None\n\n        \"\"\"\n        self.conn = create_connection(self.database)\n\n    def _close_conn(self):\n        \"\"\"\n        Close database connection\n\n        Args:\n            None\n\n        Returns:\n            None\n\n        \"\"\"\n        if self.conn is not None:\n            self.conn.close()\n\n    def get_set_id(self, url):\n        \"\"\"\n        Get the url id for a url\n        If not there, check if valid then add\n\n        Args:\n            url: url to be found\n\n        Returns:\n            None\n\n        \"\"\"\n        cur = self.conn.cursor()\n        try:\n            set_id = cur.execute(\n                \"SELECT url_id FROM catalog WHERE url = '\" + url + \"'\"\n            ).fetchone()\n        except Error:\n            pass\n        if set_id is not None:\n            set_id = set_id[0]  # Cursor returns a tuple and only want id\n        else:\n            set_id = self._add_set(url)\n        return set_id\n\n    def _add_set(self, url):\n        \"\"\"Private method, only called when url not already in catalog\"\"\"\n        sql = \"INSERT INTO catalog (url) VALUES ('\" + url + \"')\"\n        cur = self.conn.cursor()\n        cur.execute(sql)\n        self.conn.commit()\n        return cur.lastrowid\n\n    def update_catalog(self, url_id: int, dict_vals: dict):\n        set_lines = \", \".join([f\"{k}='{v}'\" for k, v in dict_vals.items()])\n        sql = \"UPDATE catalog SET %s WHERE url_id=%s\" % (set_lines, url_id)\n        cur = self.conn.cursor()\n        cur.execute(sql)\n        self.conn.commit()\n</code></pre>"},{"location":"api_docs/#solvency2_data.sqlite_handler.EiopaDB.__init__","title":"<code>__init__(database)</code>","text":"<p>Initialize the database.</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>str</code> <p>Path to the database file.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>solvency2_data\\sqlite_handler.py</code> <pre><code>def __init__(self, database):\n    \"\"\"\n    Initialize the database.\n\n    Args:\n        database (str): Path to the database file.\n\n    Returns:\n        None\n    \"\"\"\n    self.database = database\n    if not os.path.isfile(database):\n        root_folder = os.path.dirname(database)\n        if not os.path.exists(root_folder):\n            os.makedirs(root_folder)\n        create_eiopa_db(database)\n    self.set_conn()\n    logging.info(\"DB initialised\")\n</code></pre>"},{"location":"api_docs/#solvency2_data.sqlite_handler.EiopaDB.get_set_id","title":"<code>get_set_id(url)</code>","text":"<p>Get the url id for a url If not there, check if valid then add</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <p>url to be found</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>solvency2_data\\sqlite_handler.py</code> <pre><code>def get_set_id(self, url):\n    \"\"\"\n    Get the url id for a url\n    If not there, check if valid then add\n\n    Args:\n        url: url to be found\n\n    Returns:\n        None\n\n    \"\"\"\n    cur = self.conn.cursor()\n    try:\n        set_id = cur.execute(\n            \"SELECT url_id FROM catalog WHERE url = '\" + url + \"'\"\n        ).fetchone()\n    except Error:\n        pass\n    if set_id is not None:\n        set_id = set_id[0]  # Cursor returns a tuple and only want id\n    else:\n        set_id = self._add_set(url)\n    return set_id\n</code></pre>"},{"location":"api_docs/#solvency2_data.sqlite_handler.EiopaDB.reset","title":"<code>reset()</code>","text":"<p>Hard reset of the database</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>solvency2_data\\sqlite_handler.py</code> <pre><code>def reset(self):\n    \"\"\"\n    Hard reset of the database\n\n    Args:\n        None\n\n    Returns:\n        None\n\n    \"\"\"\n    if os.path.exists(self.database):\n        self._close_conn()\n        os.remove(self.database)\n    create_eiopa_db(self.database)\n    self.set_conn()\n</code></pre>"},{"location":"api_docs/#solvency2_data.sqlite_handler.EiopaDB.set_conn","title":"<code>set_conn()</code>","text":"<p>Set database connection</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>solvency2_data\\sqlite_handler.py</code> <pre><code>def set_conn(self):\n    \"\"\"\n    Set database connection\n\n    Args:\n        None\n\n    Returns:\n        None\n\n    \"\"\"\n    self.conn = create_connection(self.database)\n</code></pre>"},{"location":"api_docs/#solvency2_data.sqlite_handler.create_connection","title":"<code>create_connection(database)</code>","text":"<p>create a database connection to the SQLite database</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>str</code> <p>database specified by database file path</p> required <p>Returns:</p> Type Description <p>connection object or None</p> Source code in <code>solvency2_data\\sqlite_handler.py</code> <pre><code>def create_connection(database: str):\n    \"\"\"\n    create a database connection to the SQLite database\n\n    Args:\n        database: database specified by database file path\n\n    Returns:\n        connection object or None\n\n    \"\"\"\n    conn = None\n    try:\n        conn = sqlite3.connect(database)\n        return conn\n    except Error as e:\n        logging.error(e)\n\n    return conn\n</code></pre>"},{"location":"api_docs/#solvency2_data.sqlite_handler.create_eiopa_db","title":"<code>create_eiopa_db(database='eiopa.db')</code>","text":"<p>Create the EIOPA database</p> <p>Parameters:</p> Name Type Description Default <code>database</code> <code>str</code> <p>name of the database to be created</p> <code>'eiopa.db'</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>solvency2_data\\sqlite_handler.py</code> <pre><code>def create_eiopa_db(database: str = r\"eiopa.db\") -&gt; None:\n    \"\"\"\n    Create the EIOPA database\n\n    Args:\n        database: name of the database to be created\n\n    Returns:\n        None\n    \"\"\"\n    table_def = {\n        \"catalog\": \"\"\" CREATE TABLE IF NOT EXISTS catalog (\n                                     url_id INTEGER NOT NULL PRIMARY KEY,\n                                     url TEXT,\n                                     set_type TEXT,\n                                     primary_set BOOLEAN,\n                                     ref_date TEXT\n                                     ); \"\"\",\n        \"meta\": \"\"\" CREATE TABLE IF NOT EXISTS meta (\n                                     url_id INTEGER NOT NULL,\n                                     ref_date TEXT,\n                                     Country TEXT,\n                                     Info TEXT,\n                                     Coupon_freq INTEGER,\n                                     LLP INTEGER,\n                                     Convergence INTEGER,\n                                     UFR REAL,\n                                     alpha REAL,\n                                     CRA REAL,\n                                     VA REAL,\n                                     FOREIGN KEY (url_id) REFERENCES catalog (url_id)\n                                        ON DELETE CASCADE ON UPDATE NO ACTION\n                                     ); \"\"\",\n        \"rfr\": \"\"\" CREATE TABLE IF NOT EXISTS rfr (\n                                     url_id INTEGER NOT NULL,\n                                     ref_date TEXT,\n                                     scenario TEXT,\n                                     currency_code TEXT,\n                                     duration INTEGER,\n                                     spot REAL,\n                                     FOREIGN KEY (url_id) REFERENCES catalog (url_id)\n                                        ON DELETE CASCADE ON UPDATE NO ACTION\n                                     ); \"\"\",\n        \"spreads\": \"\"\"CREATE TABLE IF NOT EXISTS spreads (\n                                        url_id INTEGER NOT NULL,\n                                        ref_date TEXT,\n                                        type TEXT,\n                                        currency_code TEXT,\n                                        duration INTEGER,\n                                        cc_step INTEGER,\n                                        spread REAL,\n                                        FOREIGN KEY (url_id) REFERENCES catalog (url_id)\n                                        ON DELETE CASCADE ON UPDATE NO ACTION\n                                        );\"\"\",\n        \"govies\": \"\"\"CREATE TABLE IF NOT EXISTS govies (\n                                            url_id INTEGER NOT NULL,\n                                            ref_date TEXT,\n                                            country_code TEXT,\n                                            duration INTEGER,\n                                            spread REAL,\n                                            FOREIGN KEY (url_id) REFERENCES catalog (url_id)\n                                        ON DELETE CASCADE ON UPDATE NO ACTION\n                                            );\"\"\",\n        \"sym_adj\": \"\"\"CREATE TABLE IF NOT EXISTS sym_adj (\n                                    url_id INTEGER NOT NULL,\n                                    ref_date TEXT,\n                                    sym_adj REAL,\n                                    FOREIGN KEY (url_id) REFERENCES catalog (url_id)\n                                ON DELETE CASCADE ON UPDATE NO ACTION\n                                    );\"\"\",\n    }\n    # create a database connection\n    conn = create_connection(database)\n    # create tables\n    if conn is not None:\n        # create tables\n        for key, val in table_def.items():\n            exec_sql(conn, val)\n    else:\n        logging.error(\"Error! cannot create the database connection.\")\n</code></pre>"},{"location":"api_docs/#solvency2_data.sqlite_handler.exec_sql","title":"<code>exec_sql(conn, sql)</code>","text":"<p>Execute sql in connection</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <p>database connection</p> required <code>sql</code> <code>str</code> <p>sql statement to be executed</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>solvency2_data\\sqlite_handler.py</code> <pre><code>def exec_sql(conn, sql: str):\n    \"\"\"\n    Execute sql in connection\n\n    Args:\n        conn: database connection\n        sql: sql statement to be executed\n\n    Returns:\n        None\n\n    \"\"\"\n\n    try:\n        c = conn.cursor()\n        c.execute(sql)\n    except Error as e:\n        logging.error(e)\n</code></pre>"},{"location":"api_docs/#solvency2_data.alternative_extrapolation.DiscountedValue4par2forwards","title":"<code>DiscountedValue4par2forwards(sum_df=0, last_df=0, par_rate=0, forward_rate=0, t_min_k=0)</code>","text":"<p>Calculates the discounted value for two-factor parallel forwards.</p> <p>Parameters:</p> Name Type Description Default <code>sum_df</code> <code>float</code> <p>The sum of discount factors. Defaults to 0.</p> <code>0</code> <code>last_df</code> <code>float</code> <p>The last discount factor. Defaults to 0.</p> <code>0</code> <code>par_rate</code> <code>float</code> <p>The par rate. Defaults to 0.</p> <code>0</code> <code>forward_rate</code> <code>float</code> <p>The forward rate. Defaults to 0.</p> <code>0</code> <code>t_min_k</code> <code>int</code> <p>The difference between the two terms. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The calculated discounted value.</p> Source code in <code>solvency2_data\\alternative_extrapolation.py</code> <pre><code>def DiscountedValue4par2forwards(\n    sum_df: float = 0,\n    last_df: float = 0,\n    par_rate: float = 0,\n    forward_rate: float = 0,\n    t_min_k: int = 0,\n) -&gt; float:\n    \"\"\"\n    Calculates the discounted value for two-factor parallel forwards.\n\n    Args:\n        sum_df (float, optional): The sum of discount factors. Defaults to 0.\n        last_df (float, optional): The last discount factor. Defaults to 0.\n        par_rate (float, optional): The par rate. Defaults to 0.\n        forward_rate (float, optional): The forward rate. Defaults to 0.\n        t_min_k (int, optional): The difference between the two terms. Defaults to 0.\n\n    Returns:\n        float: The calculated discounted value.\n    \"\"\"\n    disc_val_1 = sum_df * par_rate\n    disc_val_2 = 0\n    for i in range(1, t_min_k + 1):\n        disc_val_1 += par_rate * last_df / ((1 + forward_rate) ** i)\n        disc_val_2 -= i * par_rate * last_df / ((1 + forward_rate) ** (i + 1))\n    disc_val_1 += last_df / ((1 + forward_rate) ** t_min_k) - 1\n    disc_val_2 -= t_min_k * last_df / ((1 + forward_rate) ** (t_min_k + 1))\n    return disc_val_1, disc_val_2\n</code></pre>"},{"location":"api_docs/#solvency2_data.alternative_extrapolation.FromParToForwards","title":"<code>FromParToForwards(term_struct=None, span=120, max_runs=MAX_RUNS, max_error=MAX_ERROR)</code>","text":"<p>Converts a par rate term structure to forward rates.</p> <p>Parameters:</p> Name Type Description Default <code>term_struct</code> <code>Series</code> <p>The par rate term structure. Defaults to None.</p> <code>None</code> <code>span</code> <code>int</code> <p>The span of the forward rates. Defaults to 120.</p> <code>120</code> <code>max_runs</code> <code>int</code> <p>The maximum number of iterations for convergence. Defaults to MAX_RUNS.</p> <code>MAX_RUNS</code> <code>max_error</code> <code>float</code> <p>The maximum error for convergence. Defaults to MAX_ERROR.</p> <code>MAX_ERROR</code> <p>Returns:</p> Type Description <p>pd.Series: The forward rates term structure.</p> Source code in <code>solvency2_data\\alternative_extrapolation.py</code> <pre><code>def FromParToForwards(\n    term_struct: pd.Series(dtype=\"float64\") = None,\n    span: int = 120,\n    max_runs: int = MAX_RUNS,\n    max_error: float = MAX_ERROR,\n):\n    \"\"\"\n    Converts a par rate term structure to forward rates.\n\n    Args:\n        term_struct (pd.Series, optional): The par rate term structure. Defaults to None.\n        span (int, optional): The span of the forward rates. Defaults to 120.\n        max_runs (int, optional): The maximum number of iterations for convergence. Defaults to MAX_RUNS.\n        max_error (float, optional): The maximum error for convergence. Defaults to MAX_ERROR.\n\n    Returns:\n        pd.Series: The forward rates term structure.\n    \"\"\"\n    forwards_struct = np.zeros(span)\n\n    sum_df = 0\n    df = 1\n    previous_maturity = 0\n    for maturity in term_struct.keys():\n        f = 0\n        t_min_k = maturity - previous_maturity\n        disc_val_1, disc_val_2 = DiscountedValue4par2forwards(\n            sum_df, df, term_struct[maturity], f, t_min_k\n        )\n        k = 0\n        while np.abs(disc_val_1) &gt;= max_error and k &lt;= max_runs:\n            f = f - disc_val_1 / disc_val_2\n            disc_val_1, disc_val_2 = DiscountedValue4par2forwards(\n                sum_df, df, term_struct[maturity], f, t_min_k\n            )\n            k = k + 1\n        for i in range(previous_maturity + 1, maturity + 1):\n            forwards_struct[i - 1] = f\n            df /= 1 + forwards_struct[i - 1]\n            sum_df += df\n        previous_maturity = maturity\n\n    for i in range(term_struct.keys()[-1], span + 1):\n        forwards_struct[i - 1] = forwards_struct[i - 2]\n\n    return pd.Series(data=forwards_struct, index=range(1, span + 1), dtype=\"float64\")\n</code></pre>"},{"location":"api_docs/#solvency2_data.alternative_extrapolation.create_swap_struct","title":"<code>create_swap_struct(rfr=None, additional_swaps={})</code>","text":"<p>Creates a swap structure.</p> <p>Parameters:</p> Name Type Description Default <code>rfr</code> <code>Series</code> <p>The risk-free rate term structure. Defaults to None.</p> <code>None</code> <code>additional_swaps</code> <code>dict</code> <p>Additional swaps to be included. Defaults to {}.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Series(dtype=float64)</code> <p>pd.Series: The swap structure.</p> Source code in <code>solvency2_data\\alternative_extrapolation.py</code> <pre><code>def create_swap_struct(\n    rfr: pd.Series(dtype=\"float64\") = None, additional_swaps: dict = {}\n) -&gt; pd.Series(dtype=\"float64\"):\n    \"\"\"\n    Creates a swap structure.\n\n    Args:\n        rfr (pd.Series, optional): The risk-free rate term structure. Defaults to None.\n        additional_swaps (dict, optional): Additional swaps to be included. Defaults to {}.\n\n    Returns:\n        pd.Series: The swap structure.\n    \"\"\"\n    swap_struct = OrderedDict()\n    denom = 0\n    for duration in range(1, 21):\n        rate = rfr[duration]\n        denom += (1 + rate) ** (-duration)\n        swap_struct[duration] = (1 - (1 + rate) ** (-duration)) / denom\n    for key in additional_swaps.keys():\n        swap_struct[key] = additional_swaps[key] - CRA\n    return pd.Series(\n        index=swap_struct.keys(), data=swap_struct.values(), dtype=\"float64\"\n    )\n</code></pre>"},{"location":"api_docs/#solvency2_data.alternative_extrapolation.forwardstruct2termstruct","title":"<code>forwardstruct2termstruct(forward_struct)</code>","text":"<p>Converts a forward rate structure to a term structure.</p> <p>Parameters:</p> Name Type Description Default <code>forward_struct</code> <code>Series</code> <p>The forward rate structure.</p> required <p>Returns:</p> Type Description <code>Series(dtype=float64)</code> <p>pd.Series: The term structure.</p> Source code in <code>solvency2_data\\alternative_extrapolation.py</code> <pre><code>def forwardstruct2termstruct(\n    forward_struct: pd.Series(dtype=\"float64\"),\n) -&gt; pd.Series(dtype=\"float64\"):\n    \"\"\"\n    Converts a forward rate structure to a term structure.\n\n    Args:\n        forward_struct (pd.Series): The forward rate structure.\n\n    Returns:\n        pd.Series: The term structure.\n    \"\"\"\n    alt_term_struct = pd.Series(index=forward_struct.index, dtype=\"float64\")\n    alt_term_struct[1] = forward_struct[1]\n    previous_forward = 1 + alt_term_struct[1]\n    for i in range(2, len(forward_struct) + 1):\n        alt_term_struct[i] = (previous_forward * (1 + forward_struct[i])) ** (1 / i) - 1\n        previous_forward = (1 + alt_term_struct[i]) ** i\n    return pd.Series(data=alt_term_struct, index=forward_struct.index, dtype=\"float64\")\n</code></pre>"},{"location":"api_docs/#solvency2_data.util.get_config","title":"<code>get_config()</code>","text":"<p>Reads the configuration from the solvency2_data.cfg file.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the configuration settings.</p> Example <p>get_config() {'[Section1]': {'key1': 'value1', 'key2': 'value2'}, '[Section2]': {'key3': 'value3'}}</p> Source code in <code>solvency2_data\\util.py</code> <pre><code>def get_config():\n    \"\"\"\n    Reads the configuration from the solvency2_data.cfg file.\n\n    Returns:\n        dict: A dictionary containing the configuration settings.\n\n    Example:\n        &gt;&gt;&gt; get_config()\n        {'[Section1]': {'key1': 'value1', 'key2': 'value2'}, '[Section2]': {'key3': 'value3'}}\n    \"\"\"\n    # look in current directory for .cfg file\n    # if not exists then take the .cfg file in the package directory\n    config = configparser.ConfigParser()\n    fname = \"solvency2_data.cfg\"\n    if os.path.isfile(fname):\n        config.read(fname)\n    else:\n        config.read(os.path.join(os.path.dirname(__file__), fname))\n    return config._sections\n</code></pre>"},{"location":"api_docs/#solvency2_data.util.set_config","title":"<code>set_config(new_value, existing_key='data_folder')</code>","text":"<p>Sets a new value for the specified key in the configuration file solvency2_data.cfg.</p> <p>Parameters:</p> Name Type Description Default <code>new_value</code> <code>str</code> <p>The new value to set for the specified key.</p> required <code>existing_key</code> <code>str</code> <p>The key whose value needs to be updated. Default is \"data_folder\".</p> <code>'data_folder'</code> <p>Returns:</p> Name Type Description <code>int</code> <p>Returns 0 upon successful completion.</p> Example <p>set_config(\"/new/data/folder\", \"data_folder\") Download paths updated 0</p> Source code in <code>solvency2_data\\util.py</code> <pre><code>def set_config(new_value: str, existing_key: str = \"data_folder\"):\n    \"\"\"\n    Sets a new value for the specified key in the configuration file solvency2_data.cfg.\n\n    Args:\n        new_value (str): The new value to set for the specified key.\n        existing_key (str): The key whose value needs to be updated. Default is \"data_folder\".\n\n    Returns:\n        int: Returns 0 upon successful completion.\n\n    Example:\n        &gt;&gt;&gt; set_config(\"/new/data/folder\", \"data_folder\")\n        Download paths updated\n        0\n    \"\"\"\n    config = configparser.ConfigParser()\n    fname = \"solvency2_data.cfg\"\n    fpath = os.path.join(os.path.dirname(__file__), fname)\n    config.read(fpath)\n\n    if existing_key == \"data_folder\":\n        for k in config[\"Directories\"]:\n            # print(k)\n            config[\"Directories\"][k] = new_value\n\n    with open(fpath, \"w\") as configfile:\n        config.write(configfile)\n    print(\"Download paths updated\")\n    return 0\n</code></pre>"},{"location":"api_example/","title":"Storing data in database","text":"<p>First generate a fresh database built using latest source code:</p> <pre><code>import logging\nimport sys\nlogging.basicConfig(format='%(asctime)s | %(levelname)s : %(message)s',\n                    level=logging.INFO, stream=sys.stdout)\n</code></pre> <pre><code># Check your environment\nprint(sys.path)\n</code></pre> <p>Create a database with:</p> <pre><code>from solvency2_data.eiopa_data import get_workspace\nfrom solvency2_data.sqlite_handler import EiopaDB\ndatabase = get_workspace()['database']\ndb = EiopaDB(database)\n</code></pre> <p>Reset the database with:</p> <pre><code># Hard reset of DB - deletes the file and all stored data and rebuilds empty DB\ndb.reset()\n</code></pre> <p>Now populate it for every month:</p> <pre><code>import solvency2_data\nsolvency2_data.refresh()\n</code></pre> <p>Now this can be indirectly queried using the API</p> <pre><code>import solvency2_data\nfrom datetime import date\nref_date = date(2020, 12, 31)\nrfr = solvency2_data.get(ref_date)\nmeta = solvency2_data.get(ref_date, 'meta')\nspr = solvency2_data.get(ref_date, 'spreads')\ngov = solvency2_data.get(ref_date, 'govies')\nsym_adj =  solvency2_data.get(ref_date, 'sym_adj')\nrfr.head()\n</code></pre> <p>Or directly queried via a SQL expression:</p> <pre><code>import pandas as pd\nsql = \"SELECT * FROM rfr\"\ndf = pd.read_sql(sql, con=db.conn)\ndf = df.loc[df.scenario=='base',['currency_code','ref_date', 'duration', 'spot']]\ndf.head()\n</code></pre> <pre><code>month_list = df.ref_date.drop_duplicates().to_list()\nmonth_list[:5]\n</code></pre> <pre><code>df['ref_date'] = df.ref_date.apply(lambda x: month_list.index(x))\ndf.head()\n</code></pre> <pre><code>eurs = df.loc[df.currency_code=='EUR', ['ref_date', 'duration', 'spot']].set_index('ref_date')\ngbps = df.loc[df.currency_code=='GBP', ['ref_date', 'duration', 'spot']].set_index('ref_date')\nchfs = df.loc[df.currency_code=='CHF', ['ref_date', 'duration', 'spot']].set_index('ref_date')\nusds = df.loc[df.currency_code=='USD', ['ref_date', 'duration', 'spot']].set_index('ref_date')\neurs.head()\n</code></pre> <pre><code>list(eurs.loc[66, 'spot'].values)[:5]\n</code></pre>"},{"location":"api_example/#now-have-some-fun-p","title":"Now have some fun :p","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\nimport matplotlib.animation as animation\nimport matplotlib.ticker as mtick\nfrom IPython.display import HTML\n\n# plt.style.use('ggplot')\nplt.xkcd()\n\nfig, ax = plt.subplots(figsize=(7, 4))\nax.set(xlim=(0, 100), ylim=(-0.01, 0.04))\n\ndate_text = ax.text(0.02, 0.9, '', transform=ax.transAxes)\n#plt.tight_layout()\nplt.gcf().subplots_adjust(bottom=0.15, left=0.15)\nplt.title('EIOPA Spots')\n\nx = list(range(1,151))\n#plt.xticks(ticks = x)\nplt.xlabel('duration (years)')\nplt.locator_params(axis='x', nbins=10)\n\npercentage = np.array(list(map(\"{:.1%}\".format, 0.005 * np.arange(-2, 10))))\nplt.yticks(ticks=0.005 * np.arange(-2, 10), labels=percentage)\nplt.ylabel('risk free spots')\n\ndate_text.set_text(month_list[0])\n\neur_start = ax.plot(x, eurs.loc[0,'spot'].values, color='b', ls='dashed', lw=2)[0]\neur_line = ax.plot(x, eurs.loc[0,'spot'].values, color='b', lw=2)[0]\n\ngbp_start = ax.plot(x, gbps.loc[0, 'spot'].values, color='y', ls='dashed', lw=2)[0]\ngbp_line = ax.plot(x, gbps.loc[0, 'spot'].values, color='y', lw=2)[0]\n\nchf_start = ax.plot(x, chfs.loc[0, 'spot'].values, color='m', ls='dashed', lw=2)[0]\nchf_line = ax.plot(x, chfs.loc[0, 'spot'].values, color='m', lw=2)[0]\n\nax.legend((eur_line, chf_line, gbp_line), ('eur', 'chf', 'gbp'), loc='lower right')\ndef animate(i):\n    key = min(i, 66)\n    date_text.set_text(month_list[key])\n    eur_line.set_ydata(list(eurs.loc[key, 'spot'].values))\n    gbp_line.set_ydata(list(gbps.loc[key, 'spot'].values))\n    chf_line.set_ydata(list(chfs.loc[key, 'spot'].values))\n\nanim = FuncAnimation(\n    fig, animate, interval=100, frames=67 + 15)\n\nplt.draw()\n#plt.show()\nHTML(anim.to_html5_video())\n</code></pre> <pre><code>\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Help us to make this package better. All contributions are welcome and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/wjwillemse/solvency2-data/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in     troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/wjwillemse/solvency2-data/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to     implement.</li> <li>Remember that this is a volunteer-driven project, and that     contributions are welcome :)</li> </ul>"},{"location":"contributing/#development","title":"Development","text":"<p>Clone the package from Github and install with</p> <pre><code>poetry install --with dev\n</code></pre> <p>and set up pre-commit</p> <pre><code>pre-commit install\n</code></pre> <p>To run the tests:</p> <pre><code>python -m unittest \n</code></pre> <p>To check and format your changes:</p> <pre><code>ruff check .   # Lint all files in the current directory.\nruff format .  # Format all files in the current directory.\n</code></pre> <p>Run pre-commit</p> <pre><code>pre-commit run --all-files\n</code></pre> <p>Build the package</p> <pre><code>poetry build\n</code></pre>"},{"location":"history/","title":"History","text":""},{"location":"history/#0123-2023-9-20","title":"0.1.23 (2023-9-20)","text":"<ul> <li>Eiopa's 2023-6-1 uses PD_CoD instead pf PD_Cod</li> </ul>"},{"location":"history/#0121-2023-3-29","title":"0.1.21 (2023-3-29)","text":"<ul> <li>Broken links from EIOPA website fixed</li> </ul>"},{"location":"history/#0119-2022-2-17","title":"0.1.19 (2022-2-17)","text":"<ul> <li>Alternative extrapolation method from DNB implemented </li> </ul>"},{"location":"history/#0118-2022-1-31","title":"0.1.18 (2022-1-31)","text":"<ul> <li>Smith-Wilson code added to package</li> </ul>"},{"location":"history/#0116-2022-1-20","title":"0.1.16 (2022-1-20)","text":"<ul> <li>Major update with database object to store downloaded rfr\\'s </li> </ul>"},{"location":"history/#0115-2021-1-29","title":"0.1.15 (2021-1-29)","text":"<ul> <li>Bug with pypi solved </li> </ul>"},{"location":"history/#0114-2021-1-25","title":"0.1.14 (2021-1-25)","text":"<ul> <li>Bug nested module solved </li> </ul>"},{"location":"history/#0113-2020-9-27","title":"0.1.13 (2020-9-27)","text":"<ul> <li>Code satisfies Flake8, solvency2_data.cfg added to pypi package </li> </ul>"},{"location":"history/#0111-2020-9-26","title":"0.1.11 (2020-9-26)","text":"<ul> <li>Bug fixes </li> </ul>"},{"location":"history/#018-2020-3-14","title":"0.1.8 (2020-3-14)","text":"<ul> <li>Configuration file added to specify data directories </li> </ul>"},{"location":"history/#017-2020-2-23","title":"0.1.7 (2020-2-23)","text":"<ul> <li>Broken links from EIOPA website fixed </li> </ul>"},{"location":"history/#015-2020-1-28","title":"0.1.5 (2020-1-28)","text":"<ul> <li>Spreads from PD_Cod Excel file added </li> </ul>"},{"location":"history/#014-2019-11-28","title":"0.1.4 (2019-11-28)","text":"<ul> <li>Solvency 2 shocked curves added. </li> </ul>"},{"location":"history/#013","title":"0.1.3","text":"<ul> <li>First working version. </li> </ul>"},{"location":"history/#011-2019-11-6","title":"0.1.1 (2019-11-6)","text":"<ul> <li>First release on PyPI. </li> </ul>"},{"location":"history/#010-2019-10-27","title":"0.1.0 (2019-10-27)","text":"<ul> <li>Development releases. </li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install solvency2-data, run this command in your terminal:</p> <pre><code>pip install solvency2_data\n</code></pre> <p>This is the preferred method to install solvency2-data, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>The sources for solvency2-data can be downloaded from the Github repo.</p> <p>You can either clone the public repository:</p> <pre><code>git clone git://github.com/wjwillemse/solvency2_data\n</code></pre> <p>Or download the tarball:</p> <pre><code>curl -OJL https://github.com/wjwillemse/solvency2_data/tarball/master\n</code></pre> <p>Once you have a copy of the source, you can install it with:</p> <pre><code>python setup.py install\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use solvency2-data in a project:</p> <pre><code>import solvency2_data\n</code></pre> <p>After installation you can use the functions in the package in for example a Jupyter notebook.</p> <p>To get the term structures per 31/12/2017 enter</p> <pre><code>    d = solvency2_data.read(\"2017-12-31\")\n</code></pre> <p>If you don't add an input datetime string, i.e. solvency2_data.read(), then the function will use now() and you will receive the most recent published term structure.</p> <p>This returns a Python dictionary with all the information about the term structures. The dictionary has the following keys</p> <ul> <li>input_date: the original date by which the function was called is     stored in the dictionary as input_date</li> <li>reference_date: the proper reference date generated from the input     date. The reference date is the most recent end of the month prior     to the input date. So if for example the input is datetime(2018,     1, 1) then the reference date is \\'20171231\\', because this the most     recent end of the month prior to the input date. The reference date     is a string because it is used in the name of the files to be     downloaded from the EIOPA-website.</li> <li>url: the url of the term structures</li> <li>name_zipfile: the name of the zip-file</li> <li>name_excelfile: the name of the Excel-file contained in the     zip-file that was downloaded</li> <li>meta: the information per term structure contained in the     Excel-file: the Coupon frequency, the Last Liquid Point, the     Convergence period, the Ultimate Forward Rate, the alpha parameter     of the Smith-Wilson algorithm, the Credit Rate Adjustment and the     Volatility adjustment</li> <li>RFR_spot_no_VA: the term structures without Volatility adjustment     (a Pandas DataFrame)</li> <li>RFR_spot_with_VA: the term structures with Volatility adjustment     (a Pandas DataFrame)</li> </ul> <p>You can get the term structure without Volatility Adjustment for the Euro by</p> <pre><code>    rates = d['RFR_spot_no_VA']['Euro']\n</code></pre> <p>This returns a Pandas Series (convert it to a Numpy array to use it in calculations).</p> <p>The package also contains the Smith-Wilson algorithm that is used to derive the original term structures published by EIOPA. You can use this algorithm to derive term structures with alternative extrapolation by changing the parameters.</p> <p>For this you can do the following. First define the liquid maturities of the term structure, together with a Python dictionary of rates. Then use the smith_wilson function.</p> <pre><code>    liquid_maturities = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 15, 20]\n   rates = d['RFR_spot_no_VA']['Euro']\n   ratesin = {num: float(rates[num]) for num in liquid_maturities}\n\n    alt_curve = smith_wilson(liquid_maturities = liquid_maturities,\n                             RatesIn = ratesin, \n                             nrofcoup = d['metadata'].loc[:, 'Euro'].Coupon_freq, \n                             cra = 0,\n                             ufr = 0,\n                             T2  = d['metadata'].loc[:, 'Euro'].LLP + \n                                   d['metadata'].loc[:, 'Euro'].Convergence)\n</code></pre> <p>In this case, we use a UFR of zero and a CRA of zero.</p>"},{"location":"usage/#configuration-file","title":"Configuration file","text":"<p>The solvency2-data.cfg specifies the directories where the downloaded zip-files and the Excel files are stored. The .cfg file can be stored in the directory from where the code is run, otherwise the .cfg file in the package directory is used.</p>"}]}